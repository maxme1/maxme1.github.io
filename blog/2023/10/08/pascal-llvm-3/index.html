
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../../01/pascal-llvm-2/">
      
      
        <link rel="next" href="../../13/pascal-llvm-4/">
      
      
      <link rel="icon" href="../../../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.4.8">
    
    
      
        <title>Compiling Pascal with LLVM: Part 3 - Let's Build Things</title>
      
    
    
      <link rel="stylesheet" href="../../../../../assets/stylesheets/main.4b4a2bd9.min.css">
      
        
        <link rel="stylesheet" href="../../../../../assets/stylesheets/palette.356b1318.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#compiling-pascal-with-llvm-part-3" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../../../.." title="Let&#39;s Build Things" class="md-header__button md-logo" aria-label="Let's Build Things" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Let's Build Things
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Compiling Pascal with LLVM: Part 3
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_2" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1v-2.26C6.19 13.47 5 11.38 5 9a7 7 0 0 1 7-7M9 21v-1h6v1a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1m3-17a5 5 0 0 0-5 5c0 2.05 1.23 3.81 3 4.58V16h4v-2.42c1.77-.77 3-2.53 3-4.58a5 5 0 0 0-5-5Z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_2">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2a7 7 0 0 0-7 7c0 2.38 1.19 4.47 3 5.74V17a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1v-2.26c1.81-1.27 3-3.36 3-5.74a7 7 0 0 0-7-7M9 21a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1v-1H9v1Z"/></svg>
      </label>
    
  
</form>
      
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
                
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" hidden>
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../../../.." title="Let&#39;s Build Things" class="md-nav__button md-logo" aria-label="Let's Build Things" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Let's Build Things
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../../../../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Blog
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Blog
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      <a href="../../../../" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Blog
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2" >
        
          
          <label class="md-nav__link" for="__nav_2_2" id="__nav_2_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Archive
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2">
            <span class="md-nav__icon md-icon"></span>
            Archive
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../../archive/2023/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    2023
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_3" >
        
          
          <label class="md-nav__link" for="__nav_2_3" id="__nav_2_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Categories
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_3">
            <span class="md-nav__icon md-icon"></span>
            Categories
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../../../../category/llvm/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    LLVM
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
                
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#typing" class="md-nav__link">
    Typing
  </a>
  
    <nav class="md-nav" aria-label="Typing">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#adding-types" class="md-nav__link">
    Adding types
  </a>
  
    <nav class="md-nav" aria-label="Adding types">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#constants" class="md-nav__link">
    Constants
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#definitions" class="md-nav__link">
    Definitions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#functions" class="md-nav__link">
    Functions
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-visitor-pattern" class="md-nav__link">
    The Visitor pattern
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#static-analysis" class="md-nav__link">
    Static analysis
  </a>
  
    <nav class="md-nav" aria-label="Static analysis">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#the-scope" class="md-nav__link">
    The scope
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#program" class="md-nav__link">
    Program
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#function" class="md-nav__link">
    Function
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#assignment" class="md-nav__link">
    Assignment
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#const" class="md-nav__link">
    Const
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#name" class="md-nav__link">
    Name
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#call" class="md-nav__link">
    Call
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dereference" class="md-nav__link">
    Dereference
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#getfield" class="md-nav__link">
    GetField
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#getitem" class="md-nav__link">
    GetItem
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#unary" class="md-nav__link">
    Unary
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#binary" class="md-nav__link">
    Binary
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expression-statement" class="md-nav__link">
    Expression statement
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#if" class="md-nav__link">
    If
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#while" class="md-nav__link">
    While
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#for" class="md-nav__link">
    For
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#casting-rules" class="md-nav__link">
    Casting rules
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#a-bit-of-magic" class="md-nav__link">
    A bit of magic
  </a>
  
    <nav class="md-nav" aria-label="A bit of magic">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#program_1" class="md-nav__link">
    Program
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#call_1" class="md-nav__link">
    Call
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#name_1" class="md-nav__link">
    Name
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
  <div class="md-content md-content--post" data-md-component="content">
    <div class="md-sidebar md-sidebar--post" data-md-component="sidebar" data-md-type="navigation">
      <div class="md-sidebar__scrollwrap">
        <div class="md-sidebar__inner md-post">
          <nav class="md-nav md-nav--primary">
            <div class="md-post__back">
              <div class="md-nav__title md-nav__container">
                <a href="../../../../" class="md-nav__link">
                  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
                  <span class="md-ellipsis">
                    Back to index
                  </span>
                </a>
              </div>
            </div>
            
            <ul class="md-post__meta md-nav__list">
              <li class="md-nav__item md-nav__item--section">
                <div class="md-post__title">
                  <span class="md-ellipsis">
                    Metadata
                  </span>
                </div>
                <nav class="md-nav">
                  <ul class="md-nav__list">
                    <li class="md-nav__item">
                      <div class="md-nav__link">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 19H5V8h14m-3-7v2H8V1H6v2H5c-1.11 0-2 .89-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2h-1V1m-1 11h-5v5h5v-5Z"/></svg>
                        <time datetime="2023-10-08 00:00:00" class="md-ellipsis">October 8, 2023</time>
                      </div>
                    </li>
                    
                    
                      <li class="md-nav__item">
                        <div class="md-nav__link">
                          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9 3v15h3V3H9m3 2 4 13 3-1-4-13-3 1M5 5v13h3V5H5M3 19v2h18v-2H3Z"/></svg>
                          <span class="md-ellipsis">
                            in
                            
                              <a href="../../../../category/llvm/">LLVM</a></span>
                        </div>
                      </li>
                    
                    
                      
                      <li class="md-nav__item">
                        <div class="md-nav__link">
                          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 20a8 8 0 0 0 8-8 8 8 0 0 0-8-8 8 8 0 0 0-8 8 8 8 0 0 0 8 8m0-18a10 10 0 0 1 10 10 10 10 0 0 1-10 10C6.47 22 2 17.5 2 12A10 10 0 0 1 12 2m.5 5v5.25l4.5 2.67-.75 1.23L11 13V7h1.5Z"/></svg>
                          <span class="md-ellipsis">
                            
                              20 min read
                            
                          </span>
                        </div>
                      </li>
                    
                  </ul>
                </nav>
              </li>
            </ul>
          </nav>
          
        </div>
      </div>
    </div>
    <article class="md-content__inner md-typeset">
      
        


<h1 id="compiling-pascal-with-llvm-part-3">Compiling Pascal with LLVM: Part 3</h1>
<h2 id="typing">Typing</h2>
<p>Today we're going to write a bit less code that last time. But don't worry, I'll compensate that with a healthy scoop of
(hopefully) new concepts!</p>
<!-- more -->

<h3 id="adding-types">Adding types</h3>
<p>First, let's fix all the crutches we left in our parser. And we'll start this by adding types.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>

<span class="n">hashable</span> <span class="o">=</span> <span class="n">dataclass</span><span class="p">(</span><span class="n">unsafe_hash</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">repr</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">DataType</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Base class for all data types &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">VoidType</span><span class="p">(</span><span class="n">DataType</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">BooleanType</span><span class="p">(</span><span class="n">DataType</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">CharType</span><span class="p">(</span><span class="n">DataType</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="nd">@hashable</span>
<span class="k">class</span> <span class="nc">SignedInt</span><span class="p">(</span><span class="n">DataType</span><span class="p">):</span>
    <span class="n">bits</span><span class="p">:</span> <span class="nb">int</span>


<span class="nd">@hashable</span>
<span class="k">class</span> <span class="nc">Floating</span><span class="p">(</span><span class="n">DataType</span><span class="p">):</span>
    <span class="n">bits</span><span class="p">:</span> <span class="nb">int</span>


<span class="nd">@hashable</span>
<span class="k">class</span> <span class="nc">Pointer</span><span class="p">(</span><span class="n">DataType</span><span class="p">):</span>
    <span class="nb">type</span><span class="p">:</span> <span class="n">DataType</span>


<span class="nd">@hashable</span>
<span class="k">class</span> <span class="nc">Reference</span><span class="p">(</span><span class="n">DataType</span><span class="p">):</span>
    <span class="nb">type</span><span class="p">:</span> <span class="n">DataType</span>

<span class="nd">@hashable</span>
<span class="k">class</span> <span class="nc">StaticArray</span><span class="p">(</span><span class="n">DataType</span><span class="p">):</span>
    <span class="n">dims</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span>
    <span class="nb">type</span><span class="p">:</span> <span class="n">DataType</span>

<span class="nd">@hashable</span>
<span class="k">class</span> <span class="nc">DynamicArray</span><span class="p">(</span><span class="n">DataType</span><span class="p">):</span>
    <span class="nb">type</span><span class="p">:</span> <span class="n">DataType</span>

<span class="nd">@hashable</span>
<span class="k">class</span> <span class="nc">Field</span><span class="p">:</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">type</span><span class="p">:</span> <span class="n">DataType</span>

<span class="nd">@hashable</span>
<span class="k">class</span> <span class="nc">Record</span><span class="p">(</span><span class="n">DataType</span><span class="p">):</span>
    <span class="n">fields</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Field</span><span class="p">]</span>

<span class="nd">@hashable</span>
<span class="k">class</span> <span class="nc">Signature</span><span class="p">:</span>
    <span class="n">args</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">DataType</span><span class="p">]</span>
    <span class="n">return_type</span><span class="p">:</span> <span class="n">DataType</span>

<span class="nd">@hashable</span>
<span class="k">class</span> <span class="nc">Function</span><span class="p">(</span><span class="n">DataType</span><span class="p">):</span>
    <span class="n">signatures</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Signature</span><span class="p">]</span>
</code></pre></div>
<p>So, we're representing types with... Python classes. Each type is an instance of <code>DataType</code>. We have some basic stuff
like bool, void, ints and floats with different numbers of bits and two kinds pointers:
<a href="https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable">pointers and references</a>.
There isn't much difference between them at runtime, it's more about language semantics. Finally, we have more complex
types like static (with dimensions known at compile time) or dynamic arrays and records 
(<a href="https://en.wikipedia.org/wiki/Struct_(C_programming_language)">structs</a>, if you're coming from C).
Finally, we introduce a special type for overloaded functions. Each of them is just a collection of <code>Signature</code>s - the
types of its arguments, and the return type.</p>
<p>Also let's create some useful types:</p>
<div class="highlight"><pre><span></span><code><span class="n">Ints</span> <span class="o">=</span> <span class="n">Byte</span><span class="p">,</span> <span class="n">Integer</span> <span class="o">=</span> <span class="n">SignedInt</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="n">SignedInt</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="n">Floats</span> <span class="o">=</span> <span class="n">Real</span><span class="p">,</span> <span class="o">=</span> <span class="n">Floating</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span>
<span class="n">Void</span><span class="p">,</span> <span class="n">Boolean</span><span class="p">,</span> <span class="n">Char</span> <span class="o">=</span> <span class="n">VoidType</span><span class="p">(),</span> <span class="n">BooleanType</span><span class="p">(),</span> <span class="n">CharType</span><span class="p">()</span>
<span class="n">TYPE_NAMES</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;integer&#39;</span><span class="p">:</span> <span class="n">Integer</span><span class="p">,</span>
    <span class="s1">&#39;real&#39;</span><span class="p">:</span> <span class="n">Real</span><span class="p">,</span>
    <span class="s1">&#39;char&#39;</span><span class="p">:</span> <span class="n">Char</span><span class="p">,</span>
    <span class="s1">&#39;byte&#39;</span><span class="p">:</span> <span class="n">Byte</span><span class="p">,</span>
    <span class="s1">&#39;boolean&#39;</span><span class="p">:</span> <span class="n">Boolean</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>
<p>We'll use <code>TYPE_NAMES</code> the parser later.
Now let's fix the parser, and add more types to it.</p>
<p>First we'll fix the nodes, by changing all <code>type: str</code> to <code>type: DataType</code>.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># I keep all the types in `types.py`</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">types</span>

<span class="nd">@unique</span>
<span class="k">class</span> <span class="nc">Const</span><span class="p">:</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">Any</span>
    <span class="nb">type</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">DataType</span>

<span class="nd">@unique</span>
<span class="k">class</span> <span class="nc">Definitions</span><span class="p">:</span>
    <span class="n">names</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Name</span><span class="p">]</span>
    <span class="nb">type</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">DataType</span>

<span class="nd">@unique</span>
<span class="k">class</span> <span class="nc">ArgDefinition</span><span class="p">:</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">Name</span>
    <span class="nb">type</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">DataType</span>

<span class="nd">@unique</span>
<span class="k">class</span> <span class="nc">Function</span><span class="p">:</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">Name</span>
    <span class="n">args</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ArgDefinition</span><span class="p">]</span>
    <span class="n">variables</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Definitions</span><span class="p">]</span>
    <span class="n">body</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span>
    <span class="n">return_type</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">DataType</span>
</code></pre></div>
<h4 id="constants">Constants</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_primary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">match</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
        <span class="k">case</span> <span class="n">TokenType</span><span class="o">.</span><span class="n">NUMBER</span><span class="p">:</span>
            <span class="n">body</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">consume</span><span class="p">()</span><span class="o">.</span><span class="n">string</span>
            <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">body</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">kind</span> <span class="ow">in</span> <span class="n">types</span><span class="o">.</span><span class="n">Ints</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">kind</span><span class="o">.</span><span class="n">bits</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">Const</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">kind</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">Const</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">body</span><span class="p">),</span> <span class="n">types</span><span class="o">.</span><span class="n">Real</span><span class="p">)</span>

        <span class="k">case</span> <span class="n">TokenType</span><span class="o">.</span><span class="n">STRING</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">consume</span><span class="p">()</span><span class="o">.</span><span class="n">string</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">ParseError</span><span class="p">(</span><span class="s1">&#39;Strings must start and end with apostrophes&#39;</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span> <span class="o">+</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\00</span><span class="s1">&#39;</span>
            <span class="k">return</span> <span class="n">Const</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">StaticArray</span><span class="p">(((</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)),),</span> <span class="n">types</span><span class="o">.</span><span class="n">Char</span><span class="p">))</span>

        <span class="c1"># ... other cases are unchanged</span>
</code></pre></div>
<p>Pretty straightforward. Strings are now just arrays of chars, floats and ints got a type instead of 'integer' and 
'real'. Also, we're being a bit smarter here, and trying to pack integers in the smallest number of bits possible.
So <code>1</code> will be of type <code>Byte</code>, while <code>1000</code> is an <code>Integer</code>. Pascal has automatic type upcasting, so this is ok.</p>
<h4 id="definitions">Definitions</h4>
<p>Now this is the most tedious part. We'll have to add support for a bunch of type definitions. 
It's pretty straightforward though, so I won't waste you time describing what's going on here.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">consumed</span><span class="p">(</span><span class="n">TokenType</span><span class="o">.</span><span class="n">CIRCUMFLEX</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_type</span><span class="p">())</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">consumed</span><span class="p">(</span><span class="n">TokenType</span><span class="o">.</span><span class="n">NAME</span><span class="p">,</span> <span class="n">string</span><span class="o">=</span><span class="s1">&#39;array&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">consumed</span><span class="p">(</span><span class="n">TokenType</span><span class="o">.</span><span class="n">LSQB</span><span class="p">):</span>
            <span class="c1"># true array</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_array_dims</span><span class="p">()]</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">consumed</span><span class="p">(</span><span class="n">TokenType</span><span class="o">.</span><span class="n">COMMA</span><span class="p">):</span>
                <span class="n">dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_array_dims</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">consume</span><span class="p">(</span><span class="n">TokenType</span><span class="o">.</span><span class="n">RSQB</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">consume</span><span class="p">(</span><span class="n">TokenType</span><span class="o">.</span><span class="n">NAME</span><span class="p">,</span> <span class="n">string</span><span class="o">=</span><span class="s1">&#39;of&#39;</span><span class="p">)</span>
            <span class="n">internal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">StaticArray</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">dims</span><span class="p">),</span> <span class="n">internal</span><span class="p">)</span>

        <span class="c1"># just a pointer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">consume</span><span class="p">(</span><span class="n">TokenType</span><span class="o">.</span><span class="n">NAME</span><span class="p">,</span> <span class="n">string</span><span class="o">=</span><span class="s1">&#39;of&#39;</span><span class="p">)</span>
        <span class="n">internal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">DynamicArray</span><span class="p">(</span><span class="n">internal</span><span class="p">)</span>

    <span class="c1"># string is just a special case of an array</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">consumed</span><span class="p">(</span><span class="n">TokenType</span><span class="o">.</span><span class="n">NAME</span><span class="p">,</span> <span class="n">string</span><span class="o">=</span><span class="s1">&#39;string&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">consumed</span><span class="p">(</span><span class="n">TokenType</span><span class="o">.</span><span class="n">LSQB</span><span class="p">):</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_dims</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">consume</span><span class="p">(</span><span class="n">TokenType</span><span class="o">.</span><span class="n">RSQB</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">StaticArray</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">Char</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">DynamicArray</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">Char</span><span class="p">)</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">consumed</span><span class="p">(</span><span class="n">TokenType</span><span class="o">.</span><span class="n">NAME</span><span class="p">,</span> <span class="n">string</span><span class="o">=</span><span class="s1">&#39;record&#39;</span><span class="p">):</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">consumed</span><span class="p">(</span><span class="n">TokenType</span><span class="o">.</span><span class="n">NAME</span><span class="p">,</span> <span class="n">string</span><span class="o">=</span><span class="s1">&#39;end&#39;</span><span class="p">):</span>
            <span class="n">definition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_definition</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">definition</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="n">fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">Field</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">definition</span><span class="o">.</span><span class="n">type</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">Record</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">fields</span><span class="p">))</span>

    <span class="n">kind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">consume</span><span class="p">(</span><span class="n">TokenType</span><span class="o">.</span><span class="n">NAME</span><span class="p">)</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">TYPE_NAMES</span><span class="p">[</span><span class="n">kind</span><span class="p">]</span>
</code></pre></div>
<p>a lot of repetitive stuff, although I managed to move some stuff out to these small functions:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_int</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">neg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">consumed</span><span class="p">(</span><span class="n">TokenType</span><span class="o">.</span><span class="n">OP</span><span class="p">,</span> <span class="n">string</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
    <span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">consume</span><span class="p">(</span><span class="n">TokenType</span><span class="o">.</span><span class="n">NUMBER</span><span class="p">)</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">neg</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">value</span>
    <span class="k">return</span> <span class="n">value</span>

<span class="k">def</span> <span class="nf">_array_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">first</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_int</span><span class="p">()</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">consumed</span><span class="p">(</span><span class="n">TokenType</span><span class="o">.</span><span class="n">DOT</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">consume</span><span class="p">(</span><span class="n">TokenType</span><span class="o">.</span><span class="n">DOT</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">first</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_int</span><span class="p">()</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="n">first</span>
</code></pre></div>
<div class="admonition note">
<p>By the way. Should the first part of array dims always be smaller than the second one? Or should we allow stuff like
<code>array[10..1] of integer</code>? I would expect the compiler to be smart enough to statically detect this <img alt="ðŸ¤”" class="twemoji" src="https://cdn.jsdelivr.net/gh/jdecked/twemoji@14.1.2/assets/svg/1f914.svg" title=":thinking_face:" /></p>
</div>
<h4 id="functions">Functions</h4>
<p>Finally, let's fix that ugly crutch in <code>_prototype</code>:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># replace</span>
<span class="k">if</span> <span class="n">mutable</span><span class="p">:</span>
    <span class="n">kind</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;reference(</span><span class="si">{</span><span class="n">kind</span><span class="si">}</span><span class="s1">)&#39;</span>

<span class="c1"># by</span>
<span class="k">if</span> <span class="n">mutable</span><span class="p">:</span>
    <span class="n">kind</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">Reference</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span>
</code></pre></div>
<h3 id="the-visitor-pattern">The Visitor pattern</h3>
<p>With all this in place, after parsing the code we get an 
<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a> or AST. From now on we'll do a lot of tree walking,
which can be quite tedious if you do it without the proper tools. </p>
<p>In functional languages such a tool is pattern matching. Yes, Python also has 
<a href="https://peps.python.org/pep-0636/">pattern matching syntax</a>, and we even used it already a few times. However, for 
tree walking I feel like it will get messy very quickly, because we'll be forced to cram all the code into a single 
function. </p>
<p>To keep things nicely separated we'll use the <a href="https://en.wikipedia.org/wiki/Visitor_pattern">visitor pattern</a>.</p>
<div class="admonition note">
<p>Another book recommendation: the Gang of Four's <a href="https://en.wikipedia.org/wiki/Design_Patterns">"Design Patterns"</a>.</p>
</div>
<p>Because we're using Python, a super dynamic language, I'll show you a handy way to implement the visitor pattern without
the need to do type checks or modify the classes we <em>visit</em>:</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">re</span>
<span class="c1"># credit: https://stackoverflow.com/a/1176023</span>
<span class="n">first_cap</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(.)([A-Z][a-z]+)&#39;</span><span class="p">)</span>
<span class="n">all_cap</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;([a-z\d])([A-Z])&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">snake_case</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">first_cap</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\1_\2&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">all_cap</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\1_\2&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">Visitor</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;_</span><span class="si">{</span><span class="n">snake_case</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)(</span><span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">after_visit</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">visit_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">after_visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">value</span>
</code></pre></div>
<p>All the fun is happening inside <code>visit</code>. We're basically doing a kind of dynamic dispatch based on the class name. So,
if we call <code>Visitor.visit(MyClass())</code>, inside it will get dispatched to <code>Visitor._my_class(value)</code>. 
I'm converting the class name from <code>CamelCase</code> to <code>snake_case</code> because of <a href="https://peps.python.org/pep-0008/">PEP8</a>.</p>
<p>There's also a useful <code>after_visit</code> method, which will come in handy pretty soon. Think of it as a <em>post-visit hook</em>.</p>
<h3 id="static-analysis">Static analysis</h3>
<p>Now that we're ready for tree walking, let's see what we actually want to do with our AST.</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">program</span><span class="w"> </span><span class="n">semantics</span><span class="o">;</span>
<span class="k">var</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">y</span><span class="o">,</span><span class="w"> </span><span class="n">z</span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="o">;</span>
<span class="w">    </span><span class="n">s</span><span class="o">:</span><span class="w"> </span><span class="k">string</span><span class="o">;</span>
<span class="w">    </span><span class="n">r</span><span class="o">:</span><span class="w"> </span><span class="k">array</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="k">record</span>
<span class="w">        </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="k">string</span><span class="o">;</span>
<span class="w">        </span><span class="n">age</span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="o">;</span>
<span class="w">    </span><span class="k">end</span><span class="o">;</span>

<span class="k">function</span><span class="w"> </span><span class="nf">double</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="o">;</span>
<span class="k">var</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="o">;</span><span class="w"> </span><span class="c1">// (1)</span>
<span class="w">    </span><span class="n">z</span><span class="o">:</span><span class="w"> </span><span class="k">array</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="kt">integer</span><span class="o">;</span><span class="w"> </span><span class="c1">// (2)</span>
<span class="k">begin</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">2</span><span class="o">;</span><span class="w"> </span><span class="c1">// (3) </span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="o">;</span><span class="w"> </span><span class="c1">// (4) </span>
<span class="k">end</span><span class="o">;</span>

<span class="k">function</span><span class="w"> </span><span class="nf">double</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">real</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="kt">real</span><span class="o">;</span><span class="w"> </span><span class="c1">// (5) </span>
<span class="k">var</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="o">;</span>
<span class="w">    </span><span class="n">z</span><span class="o">:</span><span class="w"> </span><span class="k">array</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="kt">integer</span><span class="o">;</span>
<span class="k">begin</span>
<span class="w">    </span><span class="n">s</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="s">&#39;example&#39;</span><span class="o">;</span><span class="w"> </span><span class="c1">// (6) </span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="o">;</span>
<span class="k">end</span><span class="o">;</span>

<span class="k">begin</span>
<span class="w">    </span><span class="n">r</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">25</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">;</span><span class="w"> </span><span class="c1">// (7) </span>
<span class="w">    </span><span class="n">s</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="s">&#39;start&#39;</span><span class="o">;</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="o">;</span>
<span class="w">    </span><span class="n">z</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="kt">double</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">;</span>
<span class="w">    </span><span class="nb">writeln</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">;</span>
<span class="w">    </span><span class="nb">writeln</span><span class="o">;</span><span class="w"> </span><span class="c1">// (8)</span>
<span class="k">end</span><span class="o">.</span>
</code></pre></div></td></tr></table></div>
<ol>
<li>we can shadow global variables</li>
<li>moreover, we can shadow with a variable of another type</li>
<li>which variable we're referring here? local or global?</li>
<li>this is how we define the return value</li>
<li>we can overload functions</li>
<li>referencing and changing a global variable</li>
<li>assignments can be more complex</li>
<li>we can call functions that take 0 arguments without parentheses</li>
</ol>
<p>The little program above has all the concepts we need to catch.</p>
<p><strong>Name tracking</strong>: for each <code>Name</code> node, we need to know which variable or function it refers to, which can be </p>
<ul>
<li>a simple variable</li>
<li><em>one of</em> the overloaded functions that have the same name</li>
<li>inside functions, we also have a special variable to assign the return value to</li>
</ul>
<p><strong>Type inference</strong>: for each node inside an <em>expression</em> we want to know its type as well as check for type errors and 
do type casting along the way.</p>
<p><strong>Static dispatch</strong>: because there may be overloaded functions, we need to statically determine which function the user
is referring to.</p>
<p>Now this is a lot of work, and it may be a good idea to split it into several <em>passes</em> of tree walking. But this will
require a bit more code to write, and I want to run my "Hello world" as soon as possible.</p>
<p>So, here's our new visitor</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">TypeSystem</span><span class="p">(</span><span class="n">Visitor</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># the actual types of nodes: Node -&gt; DataType</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># what the nodes should be cast to: Node -&gt; DataType</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">casting</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># what each `Name` node is referring to: Node -&gt; Node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">references</span> <span class="o">=</span> <span class="p">{}</span>
</code></pre></div>
<p>each method for <em>expression</em> nodes will have the following signature:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_my_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">expected</span><span class="p">:</span> <span class="n">DataType</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">lvalue</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataType</span><span class="p">:</span>
    <span class="c1"># ...</span>
</code></pre></div>
<p>We will specify which type the node is <code>expected</code> to have, or <code>None</code>, if we don't care. This will come in handy during 
type checks. The methods will return the actual type of the node, e.g. for <code>1 + 1</code> it will probably return <code>Byte</code>.</p>
<p>The last parameter, <code>lvalue</code>, is more interesting. Consider this statement:</p>
<div class="highlight"><pre><span></span><code><span class="n">r</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">25</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">;</span>
</code></pre></div>
<p>As we saw earlier, an assignment is basically two expressions delimited by the <code>:=</code> token.</p>
<p>Each expression has a value, and, it turns out that values come in two colors: <a href="https://en.wikipedia.org/wiki/Value_(computer_science)"><code>lvalues</code> and <code>rvalues</code></a>. 
<code>l</code> and <code>r</code>, you guessed it, stand for <code>left</code> and <code>right</code> respectively. So</p>
<div class="highlight"><pre><span></span><code><span class="n">r</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">age</span>
</code></pre></div>
<p>is an <code>lvalue</code>, and</p>
<div class="highlight"><pre><span></span><code><span class="mi">25</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
</code></pre></div>
<p>is an <code>rvalue</code> in our example.</p>
<p>The only difference between them, at least for us, will be that we'll expect <code>lvalues</code> to return a pointer. This makes
sense, because we need an address in memory in which we'll store the <code>rvalue</code> we just computed. This requirement also
covers cases like</p>
<div class="highlight"><pre><span></span><code><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">myfunc</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">;</span>
</code></pre></div>
<p>The type checker will complain that there's simply no way to compute the pointer to <code>1 + 2</code>. </p>
<div class="admonition note">
<p>Compile-time constants such as <code>1</code> or simple expressions like <code>1 + 2</code> might be optimized out by the compiler or 
even stored in a register rather than RAM, and there are no 
<a href="https://stackoverflow.com/questions/22154968/pointer-to-register-address">pointers to registers</a>!</p>
</div>
<p>Finally, we'll store types and casting information in <code>self.types</code> and <code>self.casting</code>. The <code>after_visit</code> method is the
best place to do this:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">after_visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">expected</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lvalue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># node types</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">types</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">kind</span>
    <span class="c1"># optionally add type casting, if needed</span>
    <span class="k">if</span> <span class="n">expected</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">expected</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">WrongType</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">expected</span><span class="p">)</span>

        <span class="c1"># if no casting needed - just remove it</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">expected</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">casting</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">casting</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">expected</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="n">expected</span>

    <span class="k">return</span> <span class="n">kind</span>
</code></pre></div>
<p>we'll implement <code>can_cast</code> later. For now let's just assume it knows all the casting rules, e.g. 
<code>can_cast(Byte, Integer) is True</code> but <code>can_cast(Real, Char) is False</code></p>
<h4 id="the-scope">The scope</h4>
<p>We need a place to store all the defined variables, a <em>scope</em>. Keep in mind, that functions can shadow global variables, 
so when we call a function we enter a new scope. Usually scopes are stored in a stack. When we enter a new scope we:</p>
<ol>
<li>push an empty scope (usually a dict) on top of the stack</li>
<li>define new variables by writing to the top scope</li>
<li>read variables by traversing the stack: start with the top scope and go down until you find the variable with the 
name you're looking for</li>
<li>after you're done just pop the scope from the top of the stack</li>
</ol>
<p>Let's look at an example:
<div class="highlight"><pre><span></span><code><span class="k">program</span><span class="w"> </span><span class="n">scope</span><span class="o">;</span>
<span class="k">var</span><span class="w"> </span><span class="n">a</span><span class="o">,</span><span class="w"> </span><span class="n">b</span><span class="o">,</span><span class="w"> </span><span class="n">c</span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="o">;</span>

<span class="k">function</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">d</span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="o">:</span>
<span class="k">var</span><span class="w"> </span><span class="n">c</span><span class="o">,</span><span class="w"> </span><span class="n">e</span><span class="o">:</span><span class="w"> </span><span class="kt">integer</span><span class="o">;</span>
<span class="k">begin</span>
<span class="w">    </span><span class="n">f</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">e</span><span class="o">;</span>
<span class="k">end</span><span class="o">;</span>

<span class="k">begin</span>
<span class="w">    </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">;</span>
<span class="k">end</span><span class="o">.</span>
</code></pre></div></p>
<p>After calling the function <code>f</code> we enter its scope, and our stack looks like this:</p>
<div class="highlight"><pre><span></span><code>    Global            Local
+------------+    +------------+    
| a, b, c, f | -&gt; | c, d, e, f | 
+------------+    +------------+    
</code></pre></div>
<p>So, in <code>f := a + b + c + d + e</code>, to find <code>a</code> and <code>b</code> we'll have to traverse the stack, because it's not present in 
the current <em>Local</em> scope.</p>
<p>Note that <code>f</code> is present in both scopes, and it even means different things: in <em>Global</em> it's the function <code>f</code>, in
<em>Local</em> it's the special variable we're writing the return value to.</p>
<div class="admonition note">
<p>You might ask "what about recursion?" we want to be able to call the function inside its own body. Yes, we'll get 
to that shortly, don't worry!</p>
</div>
<p>Now let's implement all this behaviour. We'll need methods for entering and leaving the scope, as well as defining 
variables and functions and referencing them by name.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>

<span class="k">class</span> <span class="nc">TypeSystem</span><span class="p">(</span><span class="n">Visitor</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scopes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_func_return_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">casting</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">references</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">desugar</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="nd">@contextmanager</span>
    <span class="k">def</span> <span class="nf">_enter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scopes</span><span class="o">.</span><span class="n">append</span><span class="p">({})</span>
        <span class="k">yield</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scopes</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</code></pre></div>
<p>So far so good, we're using a <code>list</code> here as a stack, and a small 
<a href="https://realpython.com/python-with-statement/">context manager</a> <code>_enter</code> has all the code we need for entering and 
leaving a scope.</p>
<p>Now that we're in a scope, that's how we'll define new names in it:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_store</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">kind</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">DataType</span><span class="p">,</span> <span class="n">payload</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scopes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_scopes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">kind</span><span class="p">,</span> <span class="n">payload</span>
</code></pre></div>
<p>we store a value of type <code>kind</code> by its <code>name</code> in the topmost scope. You'll see in a moment what <code>payload</code> is for.
The symmetric operation is finding a value by its name:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_resolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">scope</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scopes</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">scope</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">scope</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</code></pre></div>
<p>The scopes are <code>reversed</code>, because we want to iterate from the list's tail - the top of the stack.</p>
<p>And, finally, we store the information that a <code>Name</code> refers to a given node like so:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">references</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">destination</span>
</code></pre></div>
<p>The compiler will need this information to quickly find the pointer to the right variable or function.</p>
<h4 id="program">Program</h4>
<p>With all the pieces in place, let's start with the main stuff: the program itself and the functions:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_program</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Program</span><span class="p">):</span>
    <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enter</span><span class="p">():</span>
        <span class="c1"># vars</span>
        <span class="k">for</span> <span class="n">definitions</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">definitions</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_store_value</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">definitions</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>

        <span class="c1"># functions</span>
        <span class="n">functions</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>
            <span class="n">functions</span><span class="p">[</span><span class="n">func</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">normalized</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">funcs</span> <span class="ow">in</span> <span class="n">functions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="o">.</span><span class="n">signature</span><span class="p">:</span> <span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">funcs</span><span class="p">)),</span> <span class="n">funcs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">visit_sequence</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">functions</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visit_sequence</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
</code></pre></div>
<p>Here <code>_store_value</code> is a small util method to store <code>Name</code> nodes:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_store_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Name</span><span class="p">,</span> <span class="n">kind</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">DataType</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">(</span><span class="n">name</span><span class="o">.</span><span class="n">normalized</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">types</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">kind</span>
</code></pre></div>
<p>This is handy because when we're defining a variable we already know its type, so we can store this info on the spot. </p>
<p>For functions, though, it's not as simple because of overloading - there are several functions with the
same name. That's why we use a <code>defaultdict(list)</code> - this is a simple way to split a set of objects into groups, in our
case - functions. Next, we <code>_store</code> a single entry for each function, but save the information that will help us 
differentiate between them in the <code>payload</code>.</p>
<p>We're not done with functions yet! Besides storing the functions name in the global scope, we need to <code>visit</code> their 
bodies and resolve all the local variables. Note that we start visiting the functions only after we've defined all of
them. This will step makes sure that recursion works as expected, because we can resolve a function's name even if we 
didn't visit its body yet.</p>
<p>Finally, we simply visit each statement in the program's body.</p>
<p>For completeness, here's the body of <code>visit_sequence</code>:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">visit_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">)</span>
</code></pre></div>
<p>and <code>Name.normalized</code> is just</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Name</span><span class="p">:</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">normalized</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
</code></pre></div>
<p>which is handy, because Pascal is case-insensitive.</p>
<h4 id="function">Function</h4>
<p>Now that we're done with the hard part, visiting a <code>Function</code> node should look almost identical:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Function</span><span class="p">):</span>
    <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enter</span><span class="p">():</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_func_return_names</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">return_type</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">types</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">return_type</span>

        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_store_value</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">arg</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">definitions</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">definitions</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_store_value</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">definitions</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">visit_sequence</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_func_return_names</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</code></pre></div>
<p>Most of the code here is about handling this weird "assign to function's name to define the return value" behaviour.
Honestly, I don't know how to handle this better, so here we go: we keep a stack of <code>(return_type, function_name)</code>
pairs, which we'll use later to resolve <code>lvalue</code>s. At the very end we simply pop this pair from the stack.</p>
<p>The rest is pretty straightforward. Define the variables, don't forget about function arguments (which are also a
kind of local variables) then visit each statement in the body.</p>
<h4 id="assignment">Assignment</h4>
<p>This is one of our main nodes. Assignments are the bridge between <code>lvalues</code> and <code>rvalues</code>:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_assignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Assignment</span><span class="p">):</span>
    <span class="n">kind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">expected</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lvalue</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># no need to cast to reference in this case</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">Reference</span><span class="p">):</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="n">kind</span><span class="o">.</span><span class="n">type</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">expected</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">lvalue</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</code></pre></div>
<p>First, we get the type of the left side. Here <code>expected</code> is <code>None</code> because don't care which type we're going to store
in, we only care <code>what</code> we'll store there. That's why we visit the right side by passing the type constraint that we
received from the left side.</p>
<p>Additionally, we unwrap the potential <code>Reference</code> here: writing to a reference is the same as writing to a regular 
variable, at least from type system's perspective.</p>
<h4 id="const">Const</h4>
<p>What's the type of a <code>Const</code> node? Simple! We already stored the type while parsing:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_const</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Const</span><span class="p">,</span> <span class="n">expected</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">DataType</span><span class="p">,</span> <span class="n">lvalue</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">lvalue</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">WrongType</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">type</span>
</code></pre></div>
<p>additionally we make sure here that we're not trying to assign anything to this node, i.e. it's an <code>rvalue</code>.</p>
<h4 id="name">Name</h4>
<p>Here comes the moment of truth, this little method handles all the references to variables and functions</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Name</span><span class="p">,</span> <span class="n">expected</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">DataType</span><span class="p">,</span> <span class="n">lvalue</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
    <span class="c1"># assignment to the function&#39;s name inside a function is definition of a return value</span>
    <span class="k">if</span> <span class="n">lvalue</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_func_return_names</span><span class="p">:</span>
        <span class="n">kind</span><span class="p">,</span> <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_func_return_names</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="o">!=</span> <span class="n">types</span><span class="o">.</span><span class="n">Void</span> <span class="ow">and</span> <span class="n">target</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bind</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">kind</span>

    <span class="n">kind</span><span class="p">,</span> <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">normalized</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">Function</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">desugar</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">new</span> <span class="o">=</span> <span class="n">Call</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">expected</span><span class="p">,</span> <span class="n">lvalue</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_bind</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kind</span>
</code></pre></div>
<p>First we handle our ugly "assign to function name" case. We do this only if</p>
<ul>
<li>it's an <code>lvalue</code></li>
<li>we're inside a function i.e. <code>_func_return_names</code> isn't empty</li>
<li>we're inside a non-Void function (not a procedure), so the return type isn't <code>Void</code></li>
<li>the name we're referring to is the same as the function's name</li>
</ul>
<p>If all these conditions are met, we <code>bind</code> the current node to the function's return value.</p>
<p>Otherwise, we <code>resolve</code> the name and just <code>bind</code> it to the variable we found.</p>
<p>Finally, there's one more case we need to handle. As we saw before, you can call functions with 0 arguments without
parentheses. This is 100% legal:</p>
<div class="highlight"><pre><span></span><code><span class="k">program</span><span class="w"> </span><span class="n">legal</span><span class="o">;</span>
<span class="k">begin</span>
<span class="w">    </span><span class="nb">writeln</span><span class="o">;</span>
<span class="k">end</span><span class="o">.</span>
</code></pre></div>
<p>Looks like in the 70s programmers liked <a href="https://en.wikipedia.org/wiki/Syntactic_sugar">syntactic sugar</a> 
even more than we do today.</p>
<p>That's why we do another check - if it's a function then it's actually a function call, and we need to replace the
current node with a <code>Call(node, ())</code> - we <em>desugar</em> it and store this info to help the compiler.</p>
<h4 id="call">Call</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Call</span><span class="p">,</span> <span class="n">expected</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">DataType</span><span class="p">,</span> <span class="n">lvalue</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">Name</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">WrongType</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="c1"># get all the functions with this name</span>
    <span class="n">kind</span><span class="p">,</span> <span class="n">targets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">normalized</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">Function</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">WrongType</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span>

    <span class="c1"># choose the right function</span>
    <span class="n">signature</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dispatch</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">kind</span><span class="o">.</span><span class="n">signatures</span><span class="p">,</span> <span class="n">expected</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_bind</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">targets</span><span class="p">[</span><span class="n">signature</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">signature</span><span class="o">.</span><span class="n">return_type</span>
</code></pre></div>
<p>Handling calls is pretty straightforward: </p>
<ol>
<li>take the <code>target</code>, which <em>must</em> be a <code>Name</code>, functions aren't 
<a href="https://en.wikipedia.org/wiki/First-class_citizen">first class citizens</a> in Pascal!</li>
<li><code>resolve</code> the name and make sure we've found a function</li>
<li>if it's an overloaded function, choose the right variant based on the signatures (static dispatch)</li>
<li><code>bind</code> the <code>Name</code> node to the function we just chose</li>
</ol>
<p>All the heavy lifting is done in our <code>_dispatch</code> function:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">signatures</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">Signature</span><span class="p">],</span> <span class="n">expected</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">DataType</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">signature</span> <span class="ow">in</span> <span class="n">signatures</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">signature</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">signature</span><span class="o">.</span><span class="n">return_type</span><span class="p">,</span> <span class="n">expected</span><span class="p">):</span>
            <span class="k">continue</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">kind</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">signature</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">Reference</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Name</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">WrongType</span><span class="p">(</span><span class="s1">&#39;Only variables can be mutable arguments&#39;</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">expected</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">lvalue</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">except</span> <span class="n">WrongType</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">return</span> <span class="n">signature</span>

    <span class="k">raise</span> <span class="n">WrongType</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">expected</span><span class="p">,</span> <span class="n">signatures</span><span class="p">)</span>
</code></pre></div>
<p>Also pretty simple, just loop over all the signatures we have and try to find a match based on the number of <code>args</code>,
their types, and the <code>expected</code> return type of the function. We also check along the way, that if an argument is 
mutable we can only pass a variable to it.</p>
<p>In the end we just fail with a <code>WrongType</code> if nothing was found.</p>
<h4 id="dereference">Dereference</h4>
<p>We're done with the hard part! The rest should be a piece of cake:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_dereference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Dereference</span><span class="p">,</span> <span class="n">expected</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">DataType</span><span class="p">,</span> <span class="n">lvalue</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
    <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="n">expected</span><span class="p">),</span> <span class="n">lvalue</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">target</span><span class="o">.</span><span class="n">type</span>
</code></pre></div>
<p>visit the <code>target</code> while expecting a pointer, then return the type we point to.</p>
<h4 id="getfield">GetField</h4>
<p>More or less the same here:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_get_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">GetField</span><span class="p">,</span> <span class="n">expected</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">DataType</span><span class="p">,</span> <span class="n">lvalue</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
    <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">expected</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lvalue</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">Reference</span><span class="p">):</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">type</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">Record</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">WrongType</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">fields</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">field</span><span class="o">.</span><span class="n">type</span>

    <span class="k">raise</span> <span class="n">WrongType</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</code></pre></div>
<p>Visit the target, make sure we've got a record, find the right field by name and return its type.</p>
<h4 id="getitem">GetItem</h4>
<p>And here as well:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_get_item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">GetItem</span><span class="p">,</span> <span class="n">expected</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">DataType</span><span class="p">,</span> <span class="n">lvalue</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
    <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">expected</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lvalue</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">Reference</span><span class="p">):</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">type</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">StaticArray</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">DynamicArray</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="n">WrongType</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

    <span class="n">ndims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">StaticArray</span><span class="p">)</span> <span class="k">else</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ndims</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">WrongType</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>

    <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit_sequence</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">expected</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">Integer</span><span class="p">,</span> <span class="n">lvalue</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">type</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">Reference</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">SignedInt</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">WrongType</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">target</span><span class="o">.</span><span class="n">type</span>
</code></pre></div>
<p>The only difference is that arrays can have multiple indices and we must check that each index is an integer.</p>
<h4 id="unary">Unary</h4>
<p>Pascal doesn't have many unary operators:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_unary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Unary</span><span class="p">,</span> <span class="n">expected</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">DataType</span><span class="p">,</span> <span class="n">lvalue</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;@&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">Pointer</span><span class="p">)</span> <span class="ow">or</span> <span class="n">lvalue</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">WrongType</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">Pointer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">expected</span><span class="o">=</span><span class="n">expected</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">lvalue</span><span class="o">=</span><span class="n">lvalue</span><span class="p">))</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">expected</span><span class="p">,</span> <span class="n">lvalue</span><span class="p">)</span>
</code></pre></div>
<p>In case of taking an address (<code>@</code>) we check that it's not an <code>lvalue</code> and that we're expected to return a <code>Pointer</code>.
The rest are just <code>+</code>, <code>-</code> and <code>not</code>, which all return the same type as their argument, so we just visit the <code>value</code> 
with the same arguments.</p>
<h4 id="binary">Binary</h4>
<p>Binary operators, as always, are a bit more interesting. There's a lot of type casting going on with them, e.g. we
want to easily add a <code>Real</code> to an <code>Integer</code>, which makes perfect sense in most situations.</p>
<p>For me the simplest solution is to treat binary operators as simple functions with 2 arguments. We'll create a 
collection of such functions and use our <code>_dispatch</code> method to do all the work:</p>
<div class="highlight"><pre><span></span><code><span class="n">_numeric</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">types</span><span class="o">.</span><span class="n">Ints</span><span class="p">,</span> <span class="o">*</span><span class="n">types</span><span class="o">.</span><span class="n">Floats</span><span class="p">]</span>
<span class="n">_homogeneous</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;+&#39;</span><span class="p">:</span> <span class="n">_numeric</span><span class="p">,</span>
    <span class="s1">&#39;*&#39;</span><span class="p">:</span> <span class="n">_numeric</span><span class="p">,</span>
    <span class="s1">&#39;-&#39;</span><span class="p">:</span> <span class="n">_numeric</span><span class="p">,</span>
    <span class="s1">&#39;/&#39;</span><span class="p">:</span> <span class="n">_numeric</span><span class="p">,</span>
    <span class="s1">&#39;and&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">Boolean</span><span class="p">],</span>
    <span class="s1">&#39;or&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">Boolean</span><span class="p">],</span>
<span class="p">}</span>
<span class="n">_boolean</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;=&#39;</span><span class="p">:</span> <span class="n">_numeric</span><span class="p">,</span>
    <span class="s1">&#39;&lt;&#39;</span><span class="p">:</span> <span class="n">_numeric</span><span class="p">,</span>
    <span class="s1">&#39;&lt;=&#39;</span><span class="p">:</span> <span class="n">_numeric</span><span class="p">,</span>
    <span class="s1">&#39;&gt;&#39;</span><span class="p">:</span> <span class="n">_numeric</span><span class="p">,</span>
    <span class="s1">&#39;&gt;=&#39;</span><span class="p">:</span> <span class="n">_numeric</span><span class="p">,</span>
    <span class="s1">&#39;&lt;&gt;&#39;</span><span class="p">:</span> <span class="n">_numeric</span><span class="p">,</span>
<span class="p">}</span>
<span class="n">BINARY_SIGNATURES</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">k</span><span class="p">:</span> <span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">Signature</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vs</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">vs</span> <span class="ow">in</span> <span class="n">_homogeneous</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
<span class="p">}</span>
<span class="n">BINARY_SIGNATURES</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
    <span class="n">k</span><span class="p">:</span> <span class="p">[</span><span class="n">types</span><span class="o">.</span><span class="n">Signature</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="n">types</span><span class="o">.</span><span class="n">Boolean</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vs</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">vs</span> <span class="ow">in</span> <span class="n">_boolean</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
<span class="p">})</span>
</code></pre></div>
<p>I'm writing from memory here, so I might be wrong, but I'm pretty sure all the operators either return the same type
they received, or a <code>Boolean</code> in case of logical operators. That's what the code from above does: it synthetically 
generates a number of valid signatures for binary operators. So the <code>_binary</code> method itself becomes as easy as:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_binary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Binary</span><span class="p">,</span> <span class="n">expected</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">DataType</span><span class="p">,</span> <span class="n">lvalue</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dispatch</span><span class="p">([</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">],</span> <span class="n">BINARY_SIGNATURES</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">],</span> <span class="n">expected</span><span class="p">)</span><span class="o">.</span><span class="n">return_type</span>
</code></pre></div>
<p>Not bad at all <img alt="ðŸ˜Ž" class="twemoji" src="https://cdn.jsdelivr.net/gh/jdecked/twemoji@14.1.2/assets/svg/1f60e.svg" title=":sunglasses:" /></p>
<h4 id="expression-statement">Expression statement</h4>
<p>We're done with expressions! Now to statements. </p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_expression_statement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">ExpressionStatement</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">expected</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lvalue</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</code></pre></div>
<p>Super simple, just visit the expression, don't even care what's the return type.</p>
<h4 id="if">If</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_if</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">If</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">condition</span><span class="p">,</span> <span class="n">expected</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">Boolean</span><span class="p">,</span> <span class="n">lvalue</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">visit_sequence</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">then_</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">visit_sequence</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">else_</span><span class="p">)</span>
</code></pre></div>
<p>We visit the condition making sure it's <code>Boolean</code>.
Then we unconditionally visit both branches. This contrasts with how <code>If</code> is evaluated <em>at runtime</em>. For now we're
only interested in variables resolution and expression types, so we <em>must</em> visit both branches.</p>
<h4 id="while">While</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_while</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">While</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">condition</span><span class="p">,</span> <span class="n">expected</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">Boolean</span><span class="p">,</span> <span class="n">lvalue</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">visit_sequence</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
</code></pre></div>
<p>Almost same thing here.</p>
<h4 id="for">For</h4>
<p>And the final node:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_for</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">For</span><span class="p">):</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">expected</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lvalue</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">SignedInt</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">WrongType</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">expected</span><span class="o">=</span><span class="n">counter</span><span class="p">,</span> <span class="n">lvalue</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">expected</span><span class="o">=</span><span class="n">counter</span><span class="p">,</span> <span class="n">lvalue</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">visit_sequence</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
</code></pre></div>
<p><code>For</code> has a counter variable which we assign values to, and it must be an integer.
In rest, this is just a combination of <code>If</code> and <code>While</code>, nothing new.</p>
<h3 id="casting-rules">Casting rules</h3>
<p>As I promised, here's the <code>can_cast</code> method, that handles all type casting:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">can_cast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">DataType</span><span class="p">,</span> <span class="n">to</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">DataType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="c1"># we either don&#39;t care (to is None) or they&#39;re both the same type</span>
    <span class="k">if</span> <span class="n">to</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">to</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">match</span> <span class="n">kind</span><span class="p">,</span> <span class="n">to</span><span class="p">:</span>
        <span class="c1"># references are just a wrapper, so we&#39;ll ignore them</span>
        <span class="k">case</span><span class="w"> </span><span class="n">types</span><span class="o">.</span><span class="n">Reference</span><span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="k">_</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">to</span><span class="p">)</span>
        <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">Reference</span><span class="p">(</span><span class="n">dst</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>

        <span class="c1"># static arrays can be viewed as dynamic in some cases, if they&#39;re 1-dimensional</span>
        <span class="k">case</span> <span class="n">types</span><span class="o">.</span><span class="n">StaticArray</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">src</span><span class="p">),</span> <span class="n">types</span><span class="o">.</span><span class="n">DynamicArray</span><span class="p">(</span><span class="n">dst</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">src</span> <span class="o">==</span> <span class="n">dst</span>

        <span class="c1"># ints can be cast to floats</span>
        <span class="k">case</span><span class="w"> </span><span class="n">types</span><span class="o">.</span><span class="n">SignedInt</span><span class="p">(</span><span class="k">_</span><span class="p">),</span> <span class="n">types</span><span class="o">.</span><span class="n">Floating</span><span class="p">(</span><span class="n">_</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># basic upcasting, e.g. Byte -&gt; Integer</span>
    <span class="k">for</span> <span class="n">family</span> <span class="ow">in</span> <span class="n">types</span><span class="o">.</span><span class="n">SignedInt</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">Floating</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">family</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">family</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">kind</span><span class="o">.</span><span class="n">bits</span> <span class="o">&lt;=</span> <span class="n">to</span><span class="o">.</span><span class="n">bits</span>

    <span class="c1"># no luck</span>
    <span class="k">return</span> <span class="kc">False</span>
</code></pre></div>
<p>I added comments to the relevant parts, so this should be pretty straightforward.</p>
<h3 id="a-bit-of-magic">A bit of magic</h3>
<p>Finally, there's one more important bit that we need to talk about: <code>writeln</code>. </p>
<p>It turns out that Pascal does a bit of cheating, and exposes several <em>magic</em> functions, that can't be implemented
in the language itself. The most known of them is <code>writeln</code>: it can accept 
<a href="https://en.wikipedia.org/wiki/Variadic_function">any number of arguments</a> and each of them can have any type from a 
long list of allowed types. So, once again, this is 100% legal:</p>
<div class="highlight"><pre><span></span><code><span class="nb">writeln</span><span class="o">;</span>
<span class="nb">writeln</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">;</span>
<span class="nb">writeln</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mf">2.5</span><span class="p">)</span><span class="o">;</span>
<span class="nb">writeln</span><span class="p">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mf">2.5</span><span class="o">,</span><span class="w"> </span><span class="s">&#39;my string&#39;</span><span class="p">)</span><span class="o">;</span>
</code></pre></div>
<p>There is simply no way for us to try and squeeze this behaviour into our <code>_dispatch</code> method, in a way, <code>writeln</code> is 
<em>an infinite</em> number of overloaded functions.</p>
<p>To do this we'll introduce a new concept:</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>

<span class="k">class</span> <span class="nc">MagicFunction</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
    <span class="nd">@classmethod</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">visit</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataType</span><span class="p">:</span>
        <span class="k">pass</span>
</code></pre></div>
<div class="admonition note">
<p>Yes, at this point we could replace this class with a function, but we'll extend it later, so introducing a new
type is super legit, I promise!</p>
</div>
<p><code>validate</code> will have to, wait for it, validate the incoming arguments and decide the return type of the function.
In case of <code>writeln</code> this should look like so:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">WriteLn</span><span class="p">(</span><span class="n">MagicFunction</span><span class="p">):</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">visit</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataType</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="c1"># we can write ~almost~ anything, so we don&#39;t care about the type</span>
            <span class="n">visit</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">Void</span>
</code></pre></div>
<p>and there are a few places we'll need to add support for it, but first, let's create a registry of magic functions:</p>
<div class="highlight"><pre><span></span><code><span class="n">MAGIC_FUNCTIONS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;writeln&#39;</span><span class="p">:</span> <span class="n">WriteLn</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="program_1">Program</h4>
<p>As soon as we enter the global scope, we must define all the magic functions:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_program</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Program</span><span class="p">):</span>
    <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enter</span><span class="p">():</span>
        <span class="c1"># magic</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">magic</span> <span class="ow">in</span> <span class="n">MAGIC_FUNCTIONS</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">magic</span><span class="p">(),</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># ... the rest</span>
</code></pre></div>
<h4 id="call_1">Call</h4>
<p>Next, calling magic functions needs special treatment:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Call</span><span class="p">,</span> <span class="n">expected</span><span class="p">:</span> <span class="n">types</span><span class="o">.</span><span class="n">DataType</span><span class="p">,</span> <span class="n">lvalue</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">Name</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">WrongType</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="c1"># get all the functions with this name</span>
    <span class="n">kind</span><span class="p">,</span> <span class="n">targets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">normalized</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">MagicFunction</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">kind</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">)</span>

    <span class="c1"># ... the rest</span>
</code></pre></div>
<h4 id="name_1">Name</h4>
<p>And finally, we should desugar 0-arg calls:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># replace</span>
<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">Function</span><span class="p">):</span>

<span class="c1"># by</span>
<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">Function</span><span class="p">,</span> <span class="n">MagicFunction</span><span class="p">)):</span>
</code></pre></div>
<p>That's it! Now we have a real-life type system. This took a while, but I hope you found something useful.</p>
<p>You probably noticed that this is already the third post in this series, and still there's no LLVM in sight. In the 
next and final post we'll fix that. Next time we'll use all the concepts we built so far to compile everything to 
<a href="https://subscription.packtpub.com/book/programming/9781785280801/1/ch01lvl1sec09/getting-familiar-with-llvm-ir">LLVM's IR</a>!</p>



  



  <h2 id="__comments">Comments</h2>
  <script src="https://giscus.app/client.js"
        data-repo="maxme1/maxme1.github.io"
        data-repo-id="R_kgDOKaCvAw"
        data-category="General"
        data-category-id="DIC_kwDOKaCvA84CZx-l"
        data-mapping="title"
        data-strict="1"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="preferred_color_scheme"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
  </script>

  <!-- Synchronize Giscus theme with palette -->
  <script>
    var giscus = document.querySelector("script[src*=giscus]")

    // Set palette on initial load
    var palette = __md_get("__palette")
    if (palette && typeof palette.color === "object") {
      var theme = palette.color.scheme === "slate"
        ? "transparent_dark"
        : "light"

      // Instruct Giscus to set theme
      giscus.setAttribute("data-theme", theme)
    }

    // Register event handlers after documented loaded
    document.addEventListener("DOMContentLoaded", function() {
      var ref = document.querySelector("[data-md-component=palette]")
      ref.addEventListener("change", function() {
        var palette = __md_get("__palette")
        if (palette && typeof palette.color === "object") {
          var theme = palette.color.scheme === "slate"
            ? "transparent_dark"
            : "light"

          // Instruct Giscus to change theme
          var frame = document.querySelector(".giscus-frame")
          frame.contentWindow.postMessage(
            { giscus: { setConfig: { theme } } },
            "https://giscus.app"
          )
        }
      })
    })
  </script>

      
    </article>
  </div>

          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../../../../..", "features": ["content.code.copy", "content.code.annotate"], "search": "../../../../../assets/javascripts/workers/search.f886a092.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../../../../assets/javascripts/bundle.81fa17fe.min.js"></script>
      
    
  </body>
</html>