{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Hey! Welcome. I'm Max and I like building stuff. </p> <p>Recently I started writing a blog about some of the things I built. Check it out </p>"},{"location":"blog/","title":"Blog","text":"<p>Welcome to my blog! Here I mostly write about things that I build in my spare time.</p>"},{"location":"blog/2023/11/11/learning-a-new-language-with-llms/","title":"Learning a new language with LLMs","text":"<p>I love learning new languages, both programming and natural ones. It feels a bit magical when you realise how words in different languages are related and why they sound the way they do.</p> <p>There's been a few months since I started learning european portuguese. I really like it so far, especially how it sounds. Currently, I'm at a point where I can confidently read and understand almost any text, and, more or less, understand what native speakers are telling me. My main problem now is my vocabulary - when I want to say or write something it takes forever to recall some words.</p> <p>It's pretty funny because sometimes I just freeze trying to remember something and the person I'm talking to assumes I didn't understand anything and quickly switches to english. Yes, they say that practice is the best way to learn a new language, but how long will it take, if the first steps are so hard? </p> <p>Recently I stumbled across the TinyStories paper. It's a great read, check it out! In brief, they generated ~2.7 million stories using the typical vocabulary of a 3-4 year old. They then trained several super small language models (I'm talking 4-6 orders of magnitude smaller than GPT-4 or Llama 2) on these stories and proved that models with around 30M parameters are not only fluent in this restricted subset of english, but also show signs of basic reasoning regarding the text's content.</p> <p>Hey, if a model with just 30M parameters can do it, then I can too!</p> <p>Then it hit me. This is a great starting point to increase my vocabulary. I'll translate random texts from TinyStories to european portuguese and then fix the mistakes I made. Skipping ahead, this works even better than I expected! I literally feel how I'm memorising new words and constructs. Of course, this effect will saturate over time, but for now, this is the fastest I've ever learned a new language!</p> <p>I ended up writing a tool that simplifies most of the boilerplate. Its frontend is written in Angular, the backend is FastAPI and, of course, I use ChatGPT to fix my translations.</p> <p>As always, here you can find the full code. And here is a live version which can be used in two modes:</p> <ol> <li>Static - just a static page with a small subset of the TinyStories (~3k). It will generate a prompt that you'll have    to manually paste into the chat with ChatGPT. It's not 100% automatic, but it's free, and I tried to simplify the    process as much as I could.</li> <li>Automatic - you have access to all ~2.7mil stories and all the checks are made though API calls to ChatGPT, but    you'll need an API token for that, and most importantly, you'll need to trust me that I won't steal it! Sadly,    OpenAI's API doesn't support CORS, so I have to route all    the requests though a self-hosted proxy server.</li> </ol> <p>You can use the string <code>free</code> as the token, in which case it will be replaced with my personal token server-side. It's limited to 1 request per 10 minutes because I don't want to go broke, but I hope it should be enough.  Enjoy!</p>"},{"location":"blog/2023/11/11/learning-a-new-language-with-llms/#the-code","title":"The code","text":"<p>Warning</p> <p>I am by no means a web developer, so the TypeScript code might seem like man-made horrors beyond your comprehension.</p> <p>I won't bore you with all the code, because most of it is pretty generic. There are a couple of things that I'd like to mention though:</p> <ul> <li>It's not so simple to highlight parts of the text    in <code>textarea</code>. Here you can find a great blog post    describing the solution I ended up using. It's a bit hacky, but it gets the job done.</li> <li><code>textarea</code> is not auto-resizable by default, it has a fixed height. In my case it feels more natural to make it more    responsive. Here how it's done:    <pre><code>import { Directive, ElementRef, HostListener, Renderer2 } from '@angular/core';\n\n@Directive({\n  selector: 'textarea[autoResize]'\n})\nexport class AutoResizeTextareaDirective {\n  constructor(private el: ElementRef&lt;HTMLTextAreaElement&gt;) { }\n\n  private adjustTextareaHeight(textarea: HTMLTextAreaElement): void {\n    textarea.style.overflow = 'hidden';\n    textarea.style.height = 'auto';\n    textarea.style.height = textarea.scrollHeight + 1 + 'px';\n  }\n\n  @HostListener('input', ['$event.target'])\n  onInput(textarea: HTMLTextAreaElement): void {\n    this.adjustTextareaHeight(textarea);\n  }\n\n  ngAfterViewInit(): void {\n    this.adjustTextareaHeight(this.el.nativeElement);\n  }\n\n  ngAfterViewChecked(): void {\n    this.adjustTextareaHeight(this.el.nativeElement);\n  }\n}\n</code></pre></li> </ul> <p>So we're basically just changing the raw underlying html element on any relevant event, such as \"input\".</p> <ul> <li>To find out what parts of the text were changed, I used <code>diffWords</code> from jsdiff    with a small adjustment. By default <code>diffWords</code> will output changed segments in a \"tangled\" manner:</li> </ul> <pre><code>a: Lorem ipsum dolor sit amet\nb: Lorem ipsem dollar sit amet\ndiff: Lorem -ipsum- +ipsem+ -dolor- +dollar+ sit amet\nfixed: Lorem -ipsum dolor- +ipsem dollar+ sit amet\n</code></pre> <p>To my taste it looks nicer when all the changed parts are joined together, so we get an overall smaller diff.</p> <ul> <li>Finally, I organized the TinyStories dataset into ~1300 chunks, ordered by text length. In total, the text takes    about 2GiB of space. Theoretically, I could load it all in memory, but I've set the request limit to 1 per    second anyway, so I don't care much about speed. At runtime, I just find the right chunk, load it into memory (~2MiB),    and select a random text from it.</li> </ul> <p>That's it! It took me a few hours to build the whole thing, so there's no big revelation at the end - just a small tool doing its job. I hope you'll find it useful next time you decide to learn a new language </p>"},{"location":"blog/2023/09/29/pascal-llvm-1/","title":"Compiling Pascal with LLVM: Part 1","text":"<p>I always wanted to learn LLVM, but I never felt that there are some useful problems I could solve with it in my line of work. Eventually I decided to just have some fun and make something dumb and not useful at all. Yes, we're gonna compile Pascal! A language that I used for the last time like 15 years ago.</p> <p>This series of posts is highly inspired by the brilliant book \"Crafting interpreters\" by Bob Nystrom as well as the official tutorial for LLVM. If you're into parsers or compilers, you should definitely check them out!</p> <p>This is a series of four posts:</p> <ol> <li>Tokenization</li> <li>Parsing</li> <li>Typing</li> <li>Compilation</li> </ol> <p>And here you can view the final result!</p>"},{"location":"blog/2023/09/29/pascal-llvm-1/#why-pascal","title":"Why Pascal?","text":"<p>There are two main reasons:</p> <ul> <li>Pascal is in a kind of sweet spot: it has a pretty simple grammar, so writing a parser would be fairly easy, but it   has a lot of constructs not covered in the LLVM tutorial, like references, pointers, record types, functions   overloading, static typing and so on</li> <li>back in school my friend wrote a full-blown roguelike in Pascal, and it   would be really cool to be able to compile it by myself. So yes, nostalgia plays a role in it, duh.</li> </ul>"},{"location":"blog/2023/09/29/pascal-llvm-1/#what-youll-need","title":"What you'll need","text":"<p>Everything is written in <code>Python3.11</code> with the llvmlite package. You can find the (almost) full implementation here. It lacks some minor stuff, like subrange types, but at this point adding them is more about implementing a small interface, than inventing something new.</p> <p>Feel free to open an issue or PR if you want to contribute in any way!</p>"},{"location":"blog/2023/09/29/pascal-llvm-1/#tokenization","title":"Tokenization","text":"<p>The simplest part is tokenization. This is usually the most boring part, at least for me, so I decided to piggyback on Python's <code>tokenize</code> builtin module. We'll just need to fix a few token types, and we're good to go:</p> <pre><code>import token as _token\nimport tokenize as tknz\nfrom contextlib import suppress\n\nfrom more_itertools import peekable\n\n# a nice namespace for token types\nTokenType = _token\nFIX_EXACT = ';', '(', ')', ',', ':', ':=', '[', ']', '^', '@', '.'\n\n\ndef tokenize(text):\n    def generator():\n        for x in text.splitlines():\n            # `generate_tokens` treats too many blank lines as \"end of stream\", so we'll patch that\n            x = x.strip() or '//empty'\n            yield x\n\n    tokens = peekable(tknz.generate_tokens(generator().__next__))\n    while tokens:\n        token: tknz.TokenInfo = next(tokens)\n        # ... patch stuff here\n</code></pre> <p>Here I'm patching empty lines to avoid some unwanted behavior and I'm wrapping the stream of tokens in <code>peekable</code>. Even though I could simply gather all the tokens into a list beforehand, I like the idea that we'll be needing at most the next token to scan (and later parse) the whole grammar.</p> <p>Now let's fix the results.</p>"},{"location":"blog/2023/09/29/pascal-llvm-1/#exact-token-types","title":"Exact token types","text":"<p>By default the tokens from <code>FIX_EXACT</code> are scanned as <code>OP</code>, but we'll need more granular control over them during parsing:</p> <pre><code>if token.string in FIX_EXACT:\n    token = token._replace(type=_token.EXACT_TOKEN_TYPES[token.string])\n</code></pre>"},{"location":"blog/2023/09/29/pascal-llvm-1/#comments","title":"Comments","text":"<p>Single-line comments are beginning with <code>//</code></p> <pre><code># consume the comment\nif token.string == '//':\n    start = token.start[0]\n    with suppress(StopIteration):\n        while tokens.peek().start[0] == start:\n            next(tokens)\n</code></pre> <p>and multi-line comments are marked with <code>{}</code></p> <pre><code># and the multiline comment\nelif token.string == '{':\n    nesting = 1\n\n    try:\n        while nesting &gt; 0:\n            token = next(tokens)\n            while token.string != '}':\n                if token.string == '{':\n                    nesting += 1\n                token = next(tokens)\n\n            nesting -= 1\n\n    except StopIteration:\n        raise SyntaxError('Unmatched \"{\"') from None\n</code></pre> <p>Here I added support for nested comments. I'm not sure if Pascal originally supported them, but some implementations do, and it's pretty straightforward anyway.</p> <p>In both cases we just consume stuff until we get to the comment's end</p>"},{"location":"blog/2023/09/29/pascal-llvm-1/#various-garbage","title":"Various garbage","text":"<p>Pascal doesn't care about indentation, so:</p> <pre><code>elif token.type in (\n        TokenType.INDENT, TokenType.DEDENT, TokenType.ENCODING, TokenType.ENDMARKER, TokenType.NEWLINE\n):  \n    # do nothing\n    pass\n</code></pre>"},{"location":"blog/2023/09/29/pascal-llvm-1/#the-inequality-operator","title":"The inequality operator","text":"<p>The strangest part is the inequality operator, which is <code>&lt;&gt;</code> in Pascal</p> <pre><code># fix the `&lt;&gt;` operator\nelif token.string == '&lt;' and tokens and tokens.peek().string == '&gt;':\n    # consume the second half\n    next(tokens)\n    yield token._replace(string='&lt;&gt;')\n</code></pre>"},{"location":"blog/2023/09/29/pascal-llvm-1/#ranges","title":"Ranges","text":"<p>finally, in Pascal you can declare ranges of numbers, such as <code>1..10</code>, Python would tokenize it as <code>1.</code> (the 1.0 float)  and <code>.10</code> (the 0.1 float). Another patch to the rescue:</p> <pre><code># unpack floats\nelif token.type == TokenType.NUMBER and (token.string.startswith('.') or token.string.endswith('.')):\n    body = token.string\n    split = (\n        token._replace(string='.', type=TokenType.DOT),\n        token._replace(string=body.strip('.')),\n    )\n    if body.startswith('.'):\n        yield from split\n    else:\n        yield from split[::-1]\n</code></pre>"},{"location":"blog/2023/09/29/pascal-llvm-1/#the-rest","title":"The rest","text":"<p>and that's it, other tokens are left unchanged: <pre><code>else:\n    yield token\n</code></pre></p> <p>And here you can view the full code for tokenization.</p> <p>In the next post we'll deal with parsing. That one won't be a 4min read  </p>"},{"location":"blog/2023/10/01/pascal-llvm-2/","title":"Compiling Pascal with LLVM: Part 2","text":""},{"location":"blog/2023/10/01/pascal-llvm-2/#parsing","title":"Parsing","text":"<p>Now to the fun part. We'll be using a recursive parser, just like in Crafting interpreters, so you can easily skip this part if you're familiar with the technique. I made a slight modification to the parsing of binary operators though.</p> <p>I wrote the parser for Pascal's grammar from memory (a very long-term memory), and apparently ended up with a less restrictive grammar. I might fix that in the future though.</p> <p>We'll start with a simple class with several helper methods:</p> <pre><code>from tokenize import TokenInfo\nfrom more_itertools import peekable\nfrom ..tokenizer import TokenType\n\n\n# just for convenience\nclass ParseError(Exception):\n    pass\n\n\nclass Parser:\n    def __init__(self, tokens):\n        self.tokens = peekable(tokens)\n\n    def consume(self, *types: TokenType, string: str | None = None) -&gt; TokenInfo:\n        if not self.matches(*types, string=string):\n            raise ParseError(self.peek(), types, string)\n        return next(self.tokens)\n\n    def consumed(self, *types: TokenType, string: str | None = None) -&gt; bool:\n        success = self.matches(*types, string=string)\n        if success:\n            self.consume()\n        return success\n\n    def peek(self) -&gt; TokenInfo:\n        if not self.tokens:\n            raise ParseError\n        return self.tokens.peek()\n\n    def matches(self, *types: TokenType, string: str | None = None) -&gt; bool:\n        if not self.tokens:\n            return False\n        token = self.peek()\n        if types and token.type not in types:\n            return False\n        if string is not None and token.string.lower() != string.lower():\n            return False\n        return True\n</code></pre> <p>basically all they do is consume the next token while checking some constraints.</p> <p>Next, we'll build a collection of nodes, which the parser will have to generate.</p>"},{"location":"blog/2023/10/01/pascal-llvm-2/#expressions","title":"Expressions","text":"<p>Expressions are the parts of code that produce a value. For example, these</p> <pre><code>1 + 1\nf(1, 2, 3)\n1 + f(2) + x.count * array[0]\n</code></pre> <p>are expressions, but this isn't</p> <pre><code>if x = 1 then\nbegin\nend;\n</code></pre> <p>Technically, not all calls produce values, because Pascal makes a distinction between functions and procedures, but here we'll treat procedures as functions that return void, and let the type system worry about them.</p>"},{"location":"blog/2023/10/01/pascal-llvm-2/#literals","title":"Literals","text":"<p>The simplest expression is a literal like <code>1</code> or <code>'abc'</code>.</p> <pre><code>from dataclasses import dataclass\nfrom typing import Any\n\n# we want each node to be unique, so that two nodes with same fields still won't be equal  \nunique = dataclass(eq=False)\n\n\n@unique\nclass Const:\n    value: Any\n    type: str\n</code></pre> <p>next we'll add a <code>_primary</code> method to the <code>Parser</code>. Which will return this node:</p> <pre><code># TokenType was defined in the previous post\nfrom .tokenizer import TokenType\n\n\nclass Parser:\n    # ...\n\n    # expression is just a convenience method for now\n    def _expression(self):\n        return self._primary()\n\n    def _primary(self):\n        match self.peek().type:\n            case TokenType.NUMBER:\n                body = self.consume().string\n                if '.' not in body:\n                    return Const(int(body), 'integer')\n                return Const(float(body), 'real')\n\n            case TokenType.STRING:\n                value = self.consume().string\n                if not value.startswith(\"'\"):\n                    raise ParseError('Strings must start and end with apostrophes')\n                value = eval(value).encode() + b'\\00'\n                return Const(value, 'string')\n\n            case _:\n                raise ParseError(self.peek())\n</code></pre> <p>Here we use null-terminated strings, which is not very Pascal'ish. However, this will simplify things for us when we'll be working with C functions. </p> <p>and now you can spin up the whole thing:</p> <pre><code>text = '1'\nparser = Parser(tokenize(text))\nprint(parser._expression())\n</code></pre> <p>this should give you something like <code>Const(value=1, type='integer')</code>, and if you try and call it with</p> <pre><code>text = 'x + y'\n</code></pre> <p>it would raise a <code>ParseError</code>. So far so good!</p>"},{"location":"blog/2023/10/01/pascal-llvm-2/#names","title":"Names","text":"<p>While we're at it, let's add another simple node - name access. We'll emit it each time someone references a variable or function by its name:</p> <pre><code>@unique\nclass Name:\n    name: str\n</code></pre> <p>this will be another case in the <code>_primary</code> function:</p> <pre><code>case TokenType.NAME:\n    return Name(self.consume().string)\n</code></pre>"},{"location":"blog/2023/10/01/pascal-llvm-2/#tails","title":"Tails","text":"<p>Next we'll parse something more interesting:</p> <pre><code>f(1, 2, x, y)\nstudent.name\narray[index]\nmyPointer^\n</code></pre> <p>So, function calls, field access, array indexing and pointers dereferencing. As usual let's add some nodes first:</p> <pre><code>@unique\nclass GetItem:\n    target: Any\n    args: tuple[Any]\n\n\n@unique\nclass GetField:\n    target: Any\n    name: str\n\n\n@unique\nclass Dereference:\n    target: Any\n\n\n@unique\nclass Call:\n    target: Any\n    args: tuple[Any]\n</code></pre> <p>and a new method <code>_tail</code>. Let's start with pointers:</p> <pre><code>class Parser:\n    # ...\n\n    def _expression(self):\n        return self._tail()\n\n    def _tail(self):\n        target = self._primary()\n        while self.matches(TokenType.LSQB, TokenType.DOT, TokenType.CIRCUMFLEX, TokenType.LPAR):\n            match self.consume().type:\n                case TokenType.CIRCUMFLEX:\n                    target = Dereference(target)\n\n                # ... other cases here\n\n        return target\n</code></pre> <p>So, what's going on here?</p> <ol> <li>First we parse the target - a constant or a variable name. This is exactly what <code>_primary</code> returns</li> <li>Next, we check whether it has a tail - a dereferencing operator, a field access etc</li> <li>Finally, we wrap the target in a new node</li> </ol> <p>Also, because we use a while loop here, we'll be able to parse stuff like</p> <pre><code>f(1, 2)[3].names[0]^\n</code></pre> <p>Now let's add this logic. Field access is also as simple as</p> <pre><code>case TokenType.DOT:\n    name = self.consume(TokenType.NAME).string\n    target = GetField(target, name)\n</code></pre> <p>Here we already consumed the dot in the <code>match self.consume...</code> part, so we consume the second token, which must be a name, and finally we wrap the target in the <code>GetField</code> node.</p> <p>Finally, two more interesting tails:</p> <pre><code># array indexing\ncase TokenType.LSQB:\n    args = [self._expression()]\n    while self.consumed(TokenType.COMMA):\n        args.append(self._expression())\n    self.consume(TokenType.RSQB)\n    target = GetItem(target, tuple(args))\n\n# function call\ncase TokenType.LPAR:\n    args = []\n    while not self.matches(TokenType.RPAR):\n        if args:\n            self.consume(TokenType.COMMA)\n        args.append(self._expression())\n    self.consume(TokenType.RPAR)\n    target = Call(target, tuple(args))\n</code></pre> <p>In both cases we parse a sequence of arguments separated by commas, and consume the matching bracket at the end.</p>"},{"location":"blog/2023/10/01/pascal-llvm-2/#unary-operators","title":"Unary operators","text":"<p>In case of tails we were able to use a <code>while</code> loop, because we first needed to parse the target, and then an indefinite number of tails. In case of unary operators, though, the target comes at the very end, which means that we first need to consume all the unary operators, push them into a stack, then consume the target, and wrap it while unwinding the stack. This sounds like recursion to me:</p> <pre><code>def _unary(self):\n    if self.peek().string.lower() in ('@', 'not', '-', '+'):\n        return Unary(self.consume().string.lower(), self._unary())\n    return self._tail()\n</code></pre> <p>and let's not forget the node:</p> <pre><code>@unique\nclass Unary:\n    op: str\n    value: Any\n</code></pre>"},{"location":"blog/2023/10/01/pascal-llvm-2/#binary-operators","title":"Binary operators","text":"<p>Binary operators are particularly interesting, because with them the notion of <code>priority</code> or <code>precedence</code> arises very naturally. If you're not a lisper, then probably you wouldn't like writing</p> <pre><code>1 + 2 * 3 - 4 / 5 + 6\n</code></pre> <p>as</p> <pre><code>(((1 + (2 * 3)) - (4 / 5)) + 6)\n</code></pre> <p>this is where operators precedence kicks in.</p> <p>By the way, you should definitely check out SICP, it's a timeless classic!</p> <p>We'll parse that in the following way. First, let's group the operators by precedence:</p> <pre><code>PRIORITIES = {\n    '*': 1,\n    '/': 1,\n    'div': 1,\n    'mod': 1,\n    'and': 1,\n    '+': 2,\n    '-': 2,\n    'or': 2,\n    '&gt;': 3,\n    '&gt;=': 3,\n    '&lt;=': 3,\n    '&lt;': 3,\n    '=': 4,\n    '&lt;&gt;': 4,\n    'in': 4,\n}\nMAX_PRIORITY = max(PRIORITIES.values())\n</code></pre> <p>next we start from the operations with the lowest precedence (max priority), and try to build its arguments from terms of higher precedence:</p> <pre><code>def _binary(self, priority):\n    if priority &lt;= 0:\n        return self._unary()\n\n    left = self._binary(priority - 1)\n    while self.peek().string in PRIORITIES:\n        op = self.peek().string\n        current = PRIORITIES.get(op)\n        # only consume the operation with the same priority\n        if current != priority:\n            break\n\n        self.consume()\n        right = self._binary(current - 1)\n        left = Binary(op, left, right)\n\n    return left\n</code></pre> <p>Basically here we're saying, that</p> <pre><code>1 * 2 + 3 * 4\n</code></pre> <p>is, first of all, a <code>+</code> with its arguments <code>1 * 2</code> and <code>3 * 4</code>. This is why both <code>left</code> and <code>right</code> are assigned to operators with <code>priority - 1</code>. At the end we just fallback to <code>_unary</code> when we run out of operators.</p> <p>Finally, as always, the node:</p> <pre><code>@unique\nclass Binary:\n    op: str\n    left: Any\n    right: Any\n</code></pre> <p>and also let's update the <code>_expression</code>:</p> <pre><code>def _expression(self):\n    return self._binary(MAX_PRIORITY)\n</code></pre>"},{"location":"blog/2023/10/01/pascal-llvm-2/#parenthesis","title":"Parenthesis","text":"<p>Yes, we just got rid of parentheses with the help of precedence. Now let's add them back in!</p> <p>Parentheses have a very high priority, higher than any binary or unary operation or even a function call. So, <code>_primary</code> is the best place for them:</p> <pre><code>def _primary(self):\n    match self.peek().type:\n        case TokenType.LPAR:\n            self.consume()\n            value = self._expression()\n            self.consume(TokenType.RPAR)\n            return value\n\n        # ... previous code\n</code></pre> <p>We don't need a separate node for this branch, because the information about precedence kind of emerges in the syntax  tree by itself. However, sometimes it's a good idea to keep this information more explicit, e.g. when you're using your parser to write a code formatter.</p> <p>This took a while, but we're finally done with parsing expressions. Now you can play with the parser and generate really complex structures. Note how parentheses influence (sometimes) the structure of the syntax tree. </p>"},{"location":"blog/2023/10/01/pascal-llvm-2/#statements","title":"Statements","text":"<p>Until now, we wrote the parser starting with the deepest nodes. This is useful when you want to be able to spin up the  parser as you progress, and watch how it gets smarter. We'll do the same thing with statements, but in reverse.</p>"},{"location":"blog/2023/10/01/pascal-llvm-2/#program","title":"Program","text":"<p>We'll start with simple programs that don't contain variables or functions:</p> <pre><code>@unique\nclass Program:\n    body: tuple[Any]\n</code></pre> <p>Don't worry, we'll update this node later.</p> <pre><code>def _program(self):\n    # program name\n    self.consume(TokenType.NAME, string='program')\n    self.consume(TokenType.NAME)\n    if self.consumed(TokenType.LPAR):\n        self.consume(TokenType.NAME)\n        self.consume(TokenType.RPAR)\n\n    self.consume(TokenType.SEMI)\n\n    # the body, including the `end`\n    statements = self._body()\n\n    # final dot\n    self.consume(TokenType.DOT)\n    # no more tokens should remain\n    if self.tokens:\n        raise ParseError(self.tokens.peek())\n\n    return Program(statements)\n</code></pre> <p>The only interesting part is the name parsing. It turns out, that Pascal allows the programmer to specify the names of input and output files used, something like  <pre><code>program myName(output_file);\n</code></pre></p> <p>I didn't know that until I started googling for larger samples of Pascal code just to test my parser.</p>"},{"location":"blog/2023/10/01/pascal-llvm-2/#the-body","title":"The body","text":"<p>The body is just a sequence of statements between <code>begin</code> and <code>end</code>:</p> <pre><code>from jboc import composed\n\n# ...\n\n@composed(tuple)\ndef _body(self):\n    self.consume(TokenType.NAME, string='begin')\n    while not self.matches(TokenType.NAME, string='end'):\n        if self.matches(TokenType.NAME, string='begin'):\n            yield from self._body()\n        else:\n            yield self._statement()\n        # the semicolon is optional in the last statement\n        if not self.matches(TokenType.NAME, string='end'):\n            self.consume(TokenType.SEMI)\n    self.consume(TokenType.NAME, string='end')\n</code></pre> <p>Note that there's a special case we're dealing with: <code>begin</code>-<code>end</code> blocks can be nested. However, unlike most of modern languages, Pascal doesn't allow variables definition inside blocks, so this nesting doesn't have any semantic  implications, that's why we're just unpacking it.</p> <p>Here <code>@composed(tuple)</code> simply gathers all we've <code>yeild</code>-ed from the function into a tuple. This is handy in many situations.</p>"},{"location":"blog/2023/10/01/pascal-llvm-2/#the-statement","title":"The statement","text":"<p>For now, the only statement we know of is an expression statement, like a function call, or a useless arithmetic  operation that isn't stored anywhere: </p> <pre><code>def _statement(self):\n    value = self._expression()\n    value = ExpressionStatement(value)\n    return value\n</code></pre> <p>with a simple node</p> <pre><code>@unique\nclass ExpressionStatement:\n    value: Any\n</code></pre> <p>Aaaaand we're finally ready to parse entire (but simple) programs like this one:</p> <pre><code>program itWorks;\nbegin\n    1 + 2;\n    writeln(3, 4, 5);\n    writeln(6 + 7, 8 * 9)\nend.\n</code></pre> <p>Pretty cool! The rest is just about adding more content. Let's dig quickly through the basics.</p>"},{"location":"blog/2023/10/01/pascal-llvm-2/#if","title":"If","text":"<p>Because <code>begin</code>-<code>end</code> is only required for multiple expressions, we'll be using this util function a lot:</p> <pre><code>def _flexible_body(self):\n    if self.matches(TokenType.NAME, string='begin'):\n        return self._body()\n    return self._statement(),\n</code></pre> <p>Now let's parse some statements:</p> <pre><code>def _if(self):\n    self.consume(TokenType.NAME, string='if')\n    condition = self._expression()\n    self.consume(TokenType.NAME, string='then')\n    left = self._flexible_body()\n    if self.consumed(TokenType.NAME, string='else'):\n        right = self._flexible_body()\n    else:\n        right = ()\n    return If(condition, left, right)\n</code></pre> <p>Yep, basic if-then-else stuff.</p> <pre><code>@unique\nclass If:\n    condition: Any\n    then_: tuple[Any]\n    else_: tuple[Any]\n</code></pre>"},{"location":"blog/2023/10/01/pascal-llvm-2/#for-and-while","title":"For and while","text":"<p>This is more or less the same</p> <pre><code>def _for(self):\n    self.consume(TokenType.NAME, string='for')\n    name = Name(self.consume(TokenType.NAME).string)\n    self.consume(TokenType.COLONEQUAL)\n    start = self._expression()\n    self.consume(TokenType.NAME, string='to')\n    stop = self._expression()\n    self.consume(TokenType.NAME, string='do')\n    body = self._flexible_body()\n    return For(name, start, stop, body)\n\ndef _while(self):\n    self.consume(TokenType.NAME, string='while')\n    condition = self._expression()\n    self.consume(TokenType.NAME, string='do')\n    body = self._flexible_body()\n    return While(condition, body)\n</code></pre> <p>and the nodes </p> <pre><code>@unique\nclass For:\n    name: Name\n    start: Any\n    stop: Any\n    body: tuple[Any]\n\n@unique\nclass While:\n    condition: Any\n    body: tuple[Any]\n</code></pre>"},{"location":"blog/2023/10/01/pascal-llvm-2/#assignments","title":"Assignments","text":"<p>With new structures in place, it's time to update the <code>_statement</code>. We'll also add assignment syntax while we're at it:</p> <pre><code>def _statement(self):\n    if self.matches(TokenType.NAME, string='if'):\n        return self._if()\n    if self.matches(TokenType.NAME, string='for'):\n        return self._for()\n    if self.matches(TokenType.NAME, string='while'):\n        return self._while()\n\n    value = self._expression()\n    if isinstance(value, (Name, GetItem, GetField, Dereference)) and self.consumed(TokenType.COLONEQUAL):\n        value = Assignment(value, self._expression())\n    else:\n        value = ExpressionStatement(value)\n    return value\n</code></pre> <p>Here what's going on. The last part is all about the difference between</p> <pre><code>student.grade;\n</code></pre> <p>and</p> <pre><code>student.grade := 10;\n</code></pre> <p>Yes, that's how we assign stuff to variables in Pascal - with the  notorious walrus operator </p> <p>We can't make a difference beforehand, because the expression can have a super long tail:</p> <pre><code>students[0].math.grades[1] := 10;\n</code></pre> <p>So we'll just start parsing it like a simple expression, then check the next token. If it's <code>:=</code> - we've got an assignment, otherwise - it's a simple expression statement.</p> <p>And, of course, assignment deserves its own node:</p> <pre><code>@unique\nclass Assignment:\n    target: Name | GetItem | GetField | Dereference\n    value: Any\n</code></pre> <p>Here we only allow assignment for certain expressions, because, say, <code>1 + 1 := 3</code> doesn't make a lot of sense</p>"},{"location":"blog/2023/10/01/pascal-llvm-2/#variables","title":"Variables","text":"<p>Variable definition in Pascal can only happen in a special block before the body, to complicate things, we are  allowed to use several such blocks:</p> <pre><code>var x1, x2: integer;\n    y: real;\nvar z: string;\n</code></pre> <p>so we'll have to do more checks than usual: </p> <pre><code>@composed(tuple)\ndef _variables(self):\n    while self.consumed(TokenType.NAME, string='var'):\n        while self.peek().string.lower() not in ('var', 'function', 'procedure', 'begin'):\n            yield self._definition()\n</code></pre> <p>Here a definition is a set of names that share a type:</p> <pre><code>@unique\nclass Definitions:\n    names: tuple[Name]\n    type: str\n</code></pre> <p>and we parse it like so</p> <pre><code>def _definition(self):\n    names = [Name(self.consume(TokenType.NAME).string)]\n    while self.consumed(TokenType.COMMA):\n        names.append(Name(self.consume(TokenType.NAME).string))\n    self.consume(TokenType.COLON)\n    kind = self._type()\n    self.consume(TokenType.SEMI)\n    return Definitions(tuple(names), kind)\n</code></pre> <p><code>_type</code> for now is just</p> <pre><code>def _type(self):\n    if self.peek().string.lower() not in ('real', 'integer', 'string'):\n        raise ParseError(self.peek())\n    return self.consume().string.lower()\n</code></pre> <p>We'll seriously upgrade it in the next post, though.</p> <p>Note that I wrote <code>kind = self._type()</code> instead of <code>type = self._type()</code>. This is because <code>type</code> is a builtin name  in Python. And builtins shadowing, in most situations, is considered as bad code.</p>"},{"location":"blog/2023/10/01/pascal-llvm-2/#functions","title":"Functions","text":"<p>We're almost there, I promise! Functions are pretty similar to the main program itself: they have the same blocks +  arguments and a return type (which can be <code>void</code>):</p> <pre><code>@unique\nclass ArgDefinition:\n    name: Name\n    type: str\n\n@unique\nclass Function:\n    name: Name\n    args: tuple[ArgDefinition]\n    variables: tuple[Definitions]\n    body: tuple[Any]\n    return_type: str\n</code></pre> <p>Why am I using here <code>Name</code> instead of <code>str</code> as the function and arg names? That's because, unlike you, I know the  future! In the next post we'll make heavy use of these names wrapped in <code>Name</code>.</p> <p>All we need to parse a function is just</p> <pre><code>def _function(self):\n    name, args, ret = self._prototype()\n    variables = self._variables()\n    body = self._body()\n    self.consume(TokenType.SEMI)\n    return Function(name, args, variables, body, ret)\n</code></pre> <p>Kinda anticlimactic, right? All the interesting part happens inside the prototype:</p> <pre><code>def _prototype(self):\n    is_func = self.consumed(TokenType.NAME, string='function')\n    if not is_func:\n        self.consume(TokenType.NAME, string='procedure')\n\n    name = Name(self.consume(TokenType.NAME).string)\n\n    args = []\n    if self.consumed(TokenType.LPAR):\n        while not self.matches(TokenType.RPAR):\n            mutable = self.consumed(TokenType.NAME, string='var')\n            group = [Name(self.consume(TokenType.NAME).string)]\n            while self.consumed(TokenType.COMMA):\n                group.append(Name(self.consume(TokenType.NAME).string))\n            self.consume(TokenType.COLON)\n            kind = self._type()\n            if mutable:\n                kind = f'reference({kind})'\n            args.extend(ArgDefinition(x, kind) for x in group)\n            self.consumed(TokenType.COMMA, TokenType.SEMI)\n\n        self.consume(TokenType.RPAR)\n\n    if is_func:\n        self.consume(TokenType.COLON)\n        ret = self._type()\n    else:\n        ret = 'void'\n    self.consume(TokenType.SEMI)\n    return name, tuple(args), ret\n</code></pre> <p>Most of this should be pretty easy by now, except maybe the part with <code>kind = f'reference({kind})'</code>. What's going on  here? </p> <p>Pascal allows us to define mutable arguments in functions:</p> <pre><code>procedure inc(var x: integer);\nbegin\n    x := x + 1;\nend;\n</code></pre> <p>This function doesn't return anything, it just changes its argument inplace. All this thanks to that little <code>var</code>.  For now I added this ugly crutch <code>kind = f'reference({kind})'</code>, in the next post we'll fix it </p>"},{"location":"blog/2023/10/01/pascal-llvm-2/#final-program","title":"Final program","text":"<p>With all the parts in place this is what the program will really look like:</p> <pre><code>@unique\nclass Program:\n    variables: tuple[Definitions]\n    functions: tuple[Function]\n    body: tuple[Any]\n</code></pre> <p>and we'll parse it as simply as:</p> <pre><code>def _program(self):\n    self.consume(TokenType.NAME, string='program')\n    self.consume(TokenType.NAME)\n    if self.consumed(TokenType.LPAR):\n        self.consume(TokenType.NAME)\n        self.consume(TokenType.RPAR)\n\n    self.consume(TokenType.SEMI)\n\n    variables = self._variables()\n    functions = []\n    while self.peek().string.lower() in ('function', 'procedure'):\n        functions.append(self._function())\n\n    statements = self._body()\n\n    self.consume(TokenType.DOT)\n    if self.tokens:\n        raise ParseError(self.tokens.peek())\n\n    return Program(variables, tuple(functions), statements)\n</code></pre> <p>This wasn't as sparse as the previous post, was it? Now, with all the bits in place, let's get to something even cooler: next time we'll build an entire type system, with compile-time errors and stuff! </p>"},{"location":"blog/2023/10/08/pascal-llvm-3/","title":"Compiling Pascal with LLVM: Part 3","text":""},{"location":"blog/2023/10/08/pascal-llvm-3/#typing","title":"Typing","text":"<p>Today we're going to write a bit less code that last time. But don't worry, I'll compensate that with a healthy scoop of (hopefully) new concepts!</p>"},{"location":"blog/2023/10/08/pascal-llvm-3/#adding-types","title":"Adding types","text":"<p>First, let's fix all the crutches we left in our parser. And we'll start this by adding types.</p> <pre><code>from dataclasses import dataclass\n\nhashable = dataclass(unsafe_hash=True, repr=True)\n\n\nclass DataType:\n    \"\"\" Base class for all data types \"\"\"\n\n\nclass VoidType(DataType):\n    pass\n\n\nclass BooleanType(DataType):\n    pass\n\n\nclass CharType(DataType):\n    pass\n\n\n@hashable\nclass SignedInt(DataType):\n    bits: int\n\n\n@hashable\nclass Floating(DataType):\n    bits: int\n\n\n@hashable\nclass Pointer(DataType):\n    type: DataType\n\n\n@hashable\nclass Reference(DataType):\n    type: DataType\n\n@hashable\nclass StaticArray(DataType):\n    dims: tuple[tuple[int, int]]\n    type: DataType\n\n@hashable\nclass DynamicArray(DataType):\n    type: DataType\n\n@hashable\nclass Field:\n    name: str\n    type: DataType\n\n@hashable\nclass Record(DataType):\n    fields: tuple[Field]\n\n@hashable\nclass Signature:\n    args: tuple[DataType]\n    return_type: DataType\n\n@hashable\nclass Function(DataType):\n    signatures: tuple[Signature]\n</code></pre> <p>So, we're representing types with... Python classes. Each type is an instance of <code>DataType</code>. We have some basic stuff like bool, void, ints and floats with different numbers of bits and two kinds pointers: pointers and references. There isn't much difference between them at runtime, it's more about language semantics. Finally, we have more complex types like static (with dimensions known at compile time) or dynamic arrays and records  (structs, if you're coming from C). Finally, we introduce a special type for overloaded functions. Each of them is just a collection of <code>Signature</code>s - the types of its arguments, and the return type.</p> <p>Also let's create some useful types:</p> <pre><code>Ints = Byte, Integer = SignedInt(8), SignedInt(32)\nFloats = Real, = Floating(64),\nVoid, Boolean, Char = VoidType(), BooleanType(), CharType()\nTYPE_NAMES = {\n    'integer': Integer,\n    'real': Real,\n    'char': Char,\n    'byte': Byte,\n    'boolean': Boolean,\n}\n</code></pre> <p>We'll use <code>TYPE_NAMES</code> the parser later. Now let's fix the parser, and add more types to it.</p> <p>First we'll fix the nodes, by changing all <code>type: str</code> to <code>type: DataType</code>.</p> <pre><code># I keep all the types in `types.py`\nfrom . import types\n\n@unique\nclass Const:\n    value: Any\n    type: types.DataType\n\n@unique\nclass Definitions:\n    names: tuple[Name]\n    type: types.DataType\n\n@unique\nclass ArgDefinition:\n    name: Name\n    type: types.DataType\n\n@unique\nclass Function:\n    name: Name\n    args: tuple[ArgDefinition]\n    variables: tuple[Definitions]\n    body: tuple[Any]\n    return_type: types.DataType\n</code></pre>"},{"location":"blog/2023/10/08/pascal-llvm-3/#constants","title":"Constants","text":"<pre><code>def _primary(self):\n    match self.peek().type:\n        case TokenType.NUMBER:\n            body = self.consume().string\n            if '.' not in body:\n                value = int(body)\n                for kind in types.Ints:\n                    if value.bit_length() &lt; kind.bits:\n                        return Const(value, kind)\n\n            return Const(float(body), types.Real)\n\n        case TokenType.STRING:\n            value = self.consume().string\n            if not value.startswith(\"'\"):\n                raise ParseError('Strings must start and end with apostrophes')\n            value = eval(value).encode() + b'\\00'\n            return Const(value, types.StaticArray(((0, len(value)),), types.Char))\n\n        # ... other cases are unchanged\n</code></pre> <p>Pretty straightforward. Strings are now just arrays of chars, floats and ints got a type instead of 'integer' and  'real'. Also, we're being a bit smarter here, and trying to pack integers in the smallest number of bits possible. So <code>1</code> will be of type <code>Byte</code>, while <code>1000</code> is an <code>Integer</code>. Pascal has automatic type upcasting, so this is ok.</p>"},{"location":"blog/2023/10/08/pascal-llvm-3/#definitions","title":"Definitions","text":"<p>Now this is the most tedious part. We'll have to add support for a bunch of type definitions.  It's pretty straightforward though, so I won't waste you time describing what's going on here.</p> <pre><code>def _type(self):\n    if self.consumed(TokenType.CIRCUMFLEX):\n        return types.Pointer(self._type())\n\n    if self.consumed(TokenType.NAME, string='array'):\n        if self.consumed(TokenType.LSQB):\n            # true array\n            dims = [self._array_dims()]\n            while self.consumed(TokenType.COMMA):\n                dims.append(self._array_dims())\n            self.consume(TokenType.RSQB)\n\n            self.consume(TokenType.NAME, string='of')\n            internal = self._type()\n            return types.StaticArray(tuple(dims), internal)\n\n        # just a pointer\n        self.consume(TokenType.NAME, string='of')\n        internal = self._type()\n        return types.DynamicArray(internal)\n\n    # string is just a special case of an array\n    if self.consumed(TokenType.NAME, string='string'):\n        if self.consumed(TokenType.LSQB):\n            dims = self._array_dims(),\n            self.consume(TokenType.RSQB)\n            return types.StaticArray(dims, types.Char)\n\n        return types.DynamicArray(types.Char)\n\n    if self.consumed(TokenType.NAME, string='record'):\n        fields = []\n        while not self.consumed(TokenType.NAME, string='end'):\n            definition = self._definition()\n            for name in definition.names:\n                fields.append(types.Field(name.name, definition.type))\n        return types.Record(tuple(fields))\n\n    kind = self.consume(TokenType.NAME).string.lower()\n    return types.TYPE_NAMES[kind]\n</code></pre> <p>a lot of repetitive stuff, although I managed to move some stuff out to these small functions:</p> <pre><code>def _int(self):\n    neg = self.consumed(TokenType.OP, string='-')\n    value = int(self.consume(TokenType.NUMBER).string)\n    if neg:\n        return -value\n    return value\n\ndef _array_dims(self):\n    first = self._int()\n    if self.consumed(TokenType.DOT):\n        self.consume(TokenType.DOT)\n        return first, self._int()\n    return 0, first\n</code></pre> <p>By the way. Should the first part of array dims always be smaller than the second one? Or should we allow stuff like <code>array[10..1] of integer</code>? I would expect the compiler to be smart enough to statically detect this </p>"},{"location":"blog/2023/10/08/pascal-llvm-3/#functions","title":"Functions","text":"<p>Finally, let's fix that ugly crutch in <code>_prototype</code>:</p> <pre><code># replace\nif mutable:\n    kind = f'reference({kind})'\n\n# by\nif mutable:\n    kind = types.Reference(kind)\n</code></pre>"},{"location":"blog/2023/10/08/pascal-llvm-3/#the-visitor-pattern","title":"The Visitor pattern","text":"<p>With all this in place, after parsing the code we get an  abstract syntax tree or AST. From now on we'll do a lot of tree walking, which can be quite tedious if you do it without the proper tools. </p> <p>In functional languages such a tool is pattern matching. Yes, Python also has  pattern matching syntax, and we even used it already a few times. However, for  tree walking I feel like it will get messy very quickly, because we'll be forced to cram all the code into a single  function. </p> <p>To keep things nicely separated we'll use the visitor pattern.</p> <p>Another book recommendation: the Gang of Four's \"Design Patterns\".</p> <p>Because we're using Python, a super dynamic language, I'll show you a handy way to implement the visitor pattern without the need to do type checks or modify the classes we visit:</p> <pre><code>import re\n# credit: https://stackoverflow.com/a/1176023\nfirst_cap = re.compile(r'(.)([A-Z][a-z]+)')\nall_cap = re.compile(r'([a-z\\d])([A-Z])')\n\ndef snake_case(name):\n    name = first_cap.sub(r'\\1_\\2', name)\n    return all_cap.sub(r'\\1_\\2', name).lower()\n\nclass Visitor:\n    def visit(self, node, *args, **kwargs):\n        value = getattr(self, f'_{snake_case(type(node).__name__)}')(node, *args, **kwargs)\n        value = self.after_visit(node, value, *args, **kwargs)\n        return value\n\n    def visit_sequence(self, nodes, *args, **kwargs):\n        return tuple(self.visit(node, *args, **kwargs) for node in nodes)\n\n    def after_visit(self, node, value, *args, **kwargs):\n        return value\n</code></pre> <p>All the fun is happening inside <code>visit</code>. We're basically doing a kind of dynamic dispatch based on the class name. So, if we call <code>Visitor.visit(MyClass())</code>, inside it will get dispatched to <code>Visitor._my_class(value)</code>.  I'm converting the class name from <code>CamelCase</code> to <code>snake_case</code> because of PEP8.</p> <p>There's also a useful <code>after_visit</code> method, which will come in handy pretty soon. Think of it as a post-visit hook.</p>"},{"location":"blog/2023/10/08/pascal-llvm-3/#static-analysis","title":"Static analysis","text":"<p>Now that we're ready for tree walking, let's see what we actually want to do with our AST.</p> <pre><code>program semantics;\nvar x, y, z: integer;\n    s: string;\n    r: array[10] of record\n        name: string;\n        age: integer;\n    end;\n\nfunction double(x: integer): integer;\nvar y: integer; // (1)\n    z: array[10] of integer; // (2)\nbegin\n    y := 2; // (3) \n    double := x * 2; // (4) \nend;\n\nfunction double(x: real): real; // (5) \nvar y: integer;\n    z: array[10] of integer;\nbegin\n    s := 'example'; // (6) \n    double := x * 2;\nend;\n\nbegin\n    r[5].age = 25 + 1; // (7) \n    s := 'start';\n    y := 0;\n    z := double(y);\n    writeln(z);\n    writeln; // (8)\nend.\n</code></pre> <ol> <li>we can shadow global variables</li> <li>moreover, we can shadow with a variable of another type</li> <li>which variable we're referring here? local or global?</li> <li>this is how we define the return value</li> <li>we can overload functions</li> <li>referencing and changing a global variable</li> <li>assignments can be more complex</li> <li>we can call functions that take 0 arguments without parentheses</li> </ol> <p>The little program above has all the concepts we need to catch.</p> <p>Name tracking: for each <code>Name</code> node, we need to know which variable or function it refers to, which can be </p> <ul> <li>a simple variable</li> <li>one of the overloaded functions that have the same name</li> <li>inside functions, we also have a special variable to assign the return value to</li> </ul> <p>Type inference: for each node inside an expression we want to know its type as well as check for type errors and  do type casting along the way.</p> <p>Static dispatch: because there may be overloaded functions, we need to statically determine which function the user is referring to.</p> <p>Now this is a lot of work, and it may be a good idea to split it into several passes of tree walking. But this will require a bit more code to write, and I want to run my \"Hello world\" as soon as possible.</p> <p>So, here's our new visitor</p> <pre><code>class TypeSystem(Visitor):\n    def __init__(self):\n        # the actual types of nodes: Node -&gt; DataType\n        self.types = {}\n        # what the nodes should be cast to: Node -&gt; DataType\n        self.casting = {}\n        # what each `Name` node is referring to: Node -&gt; Node\n        self.references = {}\n</code></pre> <p>each method for expression nodes will have the following signature:</p> <pre><code>def _my_node(self, node, expected: DataType | None, lvalue: bool) -&gt; DataType:\n    # ...\n</code></pre> <p>We will specify which type the node is <code>expected</code> to have, or <code>None</code>, if we don't care. This will come in handy during  type checks. The methods will return the actual type of the node, e.g. for <code>1 + 1</code> it will probably return <code>Byte</code>.</p> <p>The last parameter, <code>lvalue</code>, is more interesting. Consider this statement:</p> <pre><code>r[5].age = 25 + 1;\n</code></pre> <p>As we saw earlier, an assignment is basically two expressions delimited by the <code>:=</code> token.</p> <p>Each expression has a value, and, it turns out that values come in two colors: <code>lvalues</code> and <code>rvalues</code>.  <code>l</code> and <code>r</code>, you guessed it, stand for <code>left</code> and <code>right</code> respectively. So</p> <pre><code>r[5].age\n</code></pre> <p>is an <code>lvalue</code>, and</p> <pre><code>25 + 1\n</code></pre> <p>is an <code>rvalue</code> in our example.</p> <p>The only difference between them, at least for us, will be that we'll expect <code>lvalues</code> to return a pointer. This makes sense, because we need an address in memory in which we'll store the <code>rvalue</code> we just computed. This requirement also covers cases like</p> <pre><code>1 + 2 := myfunc(3);\n</code></pre> <p>The type checker will complain that there's simply no way to compute the pointer to <code>1 + 2</code>. </p> <p>Compile-time constants such as <code>1</code> or simple expressions like <code>1 + 2</code> might be optimized out by the compiler or  even stored in a register rather than RAM, and there are no  pointers to registers!</p> <p>Finally, we'll store types and casting information in <code>self.types</code> and <code>self.casting</code>. The <code>after_visit</code> method is the best place to do this:</p> <pre><code>def after_visit(self, node, kind, expected=None, lvalue=None):\n    # node types\n    self.types[node] = kind\n    # optionally add type casting, if needed\n    if expected is not None:\n        if not self.can_cast(kind, expected):\n            raise WrongType(kind, expected)\n\n        # if no casting needed - just remove it\n        if kind == expected:\n            self.casting.pop(node, None)\n        else:\n            self.casting[node] = expected\n            kind = expected\n\n    return kind\n</code></pre> <p>we'll implement <code>can_cast</code> later. For now let's just assume it knows all the casting rules, e.g.  <code>can_cast(Byte, Integer) is True</code> but <code>can_cast(Real, Char) is False</code></p>"},{"location":"blog/2023/10/08/pascal-llvm-3/#the-scope","title":"The scope","text":"<p>We need a place to store all the defined variables, a scope. Keep in mind, that functions can shadow global variables,  so when we call a function we enter a new scope. Usually scopes are stored in a stack. When we enter a new scope we:</p> <ol> <li>push an empty scope (usually a dict) on top of the stack</li> <li>define new variables by writing to the top scope</li> <li>read variables by traversing the stack: start with the top scope and go down until you find the variable with the  name you're looking for</li> <li>after you're done just pop the scope from the top of the stack</li> </ol> <p>Let's look at an example: <pre><code>program scope;\nvar a, b, c: integer;\n\nfunction f(d: integer): integer:\nvar c, e: integer;\nbegin\n    f := a + b + c + d + e;\nend;\n\nbegin\n    f(1);\nend.\n</code></pre></p> <p>After calling the function <code>f</code> we enter its scope, and our stack looks like this:</p> <pre><code>    Global            Local\n+------------+    +------------+    \n| a, b, c, f | -&gt; | c, d, e, f | \n+------------+    +------------+    \n</code></pre> <p>So, in <code>f := a + b + c + d + e</code>, to find <code>a</code> and <code>b</code> we'll have to traverse the stack, because it's not present in  the current Local scope.</p> <p>Note that <code>f</code> is present in both scopes, and it even means different things: in Global it's the function <code>f</code>, in Local it's the special variable we're writing the return value to.</p> <p>You might ask \"what about recursion?\" we want to be able to call the function inside its own body. Yes, we'll get  to that shortly, don't worry!</p> <p>Now let's implement all this behaviour. We'll need methods for entering and leaving the scope, as well as defining  variables and functions and referencing them by name.</p> <pre><code>from contextlib import contextmanager\n\nclass TypeSystem(Visitor):\n    def __init__(self):\n        self._scopes = []\n        self._func_return_names = []\n        self.types = {}\n        self.casting = {}\n        self.references = {}\n        self.desugar = {}\n\n    @contextmanager\n    def _enter(self):\n        self._scopes.append({})\n        yield\n        self._scopes.pop()\n</code></pre> <p>So far so good, we're using a <code>list</code> here as a stack, and a small  context manager <code>_enter</code> has all the code we need for entering and  leaving a scope.</p> <p>Now that we're in a scope, that's how we'll define new names in it:</p> <pre><code>def _store(self, name: str, kind: types.DataType, payload):\n    assert name not in self._scopes[-1]\n    self._scopes[-1][name] = kind, payload\n</code></pre> <p>we store a value of type <code>kind</code> by its <code>name</code> in the topmost scope. You'll see in a moment what <code>payload</code> is for. The symmetric operation is finding a value by its name:</p> <pre><code>def _resolve(self, name: str):\n    for scope in reversed(self._scopes):\n        if name in scope:\n            return scope[name]\n\n    raise KeyError(name)\n</code></pre> <p>The scopes are <code>reversed</code>, because we want to iterate from the list's tail - the top of the stack.</p> <p>And, finally, we store the information that a <code>Name</code> refers to a given node like so:</p> <pre><code>def _bind(self, source, destination):\n    self.references[source] = destination\n</code></pre> <p>The compiler will need this information to quickly find the pointer to the right variable or function.</p>"},{"location":"blog/2023/10/08/pascal-llvm-3/#program","title":"Program","text":"<p>With all the pieces in place, let's start with the main stuff: the program itself and the functions:</p> <pre><code>def _program(self, node: Program):\n    with self._enter():\n        # vars\n        for definitions in node.variables:\n            for name in definitions.names:\n                self._store_value(name, definitions.type)\n\n        # functions\n        functions = defaultdict(list)\n        for func in node.functions:\n            functions[func.name.normalized].append(func)\n        for name, funcs in functions.items():\n            funcs = {f.signature: f for f in funcs}\n            self._store(name, types.Function(tuple(funcs)), funcs)\n\n        self.visit_sequence(node.functions)\n        self.visit_sequence(node.body)\n</code></pre> <p>Here <code>_store_value</code> is a small util method to store <code>Name</code> nodes:</p> <pre><code>def _store_value(self, name: Name, kind: types.DataType):\n    self._store(name.normalized, kind, name)\n    self.types[name] = kind\n</code></pre> <p>This is handy because when we're defining a variable we already know its type, so we can store this info on the spot. </p> <p>For functions, though, it's not as simple because of overloading - there are several functions with the same name. That's why we use a <code>defaultdict(list)</code> - this is a simple way to split a set of objects into groups, in our case - functions. Next, we <code>_store</code> a single entry for each function, but save the information that will help us  differentiate between them in the <code>payload</code>.</p> <p>We're not done with functions yet! Besides storing the functions name in the global scope, we need to <code>visit</code> their  bodies and resolve all the local variables. Note that we start visiting the functions only after we've defined all of them. This will step makes sure that recursion works as expected, because we can resolve a function's name even if we  didn't visit its body yet.</p> <p>Finally, we simply visit each statement in the program's body.</p> <p>For completeness, here's the body of <code>visit_sequence</code>:</p> <pre><code>def visit_sequence(self, nodes, *args, **kwargs):\n    return tuple(self.visit(node, *args, **kwargs) for node in nodes)\n</code></pre> <p>and <code>Name.normalized</code> is just</p> <pre><code>class Name:\n    name: str\n\n    @property\n    def normalized(self):\n        return self.name.lower()\n</code></pre> <p>which is handy, because Pascal is case-insensitive.</p>"},{"location":"blog/2023/10/08/pascal-llvm-3/#function","title":"Function","text":"<p>Now that we're done with the hard part, visiting a <code>Function</code> node should look almost identical:</p> <pre><code>def _function(self, node: Function):\n    with self._enter():\n        self._func_return_names.append((node.name, node.return_type))\n        self.types[node.name] = node.return_type\n\n        for arg in node.args:\n            self._store_value(arg.name, arg.type)\n\n        for definitions in node.variables:\n            for name in definitions.names:\n                self._store_value(name, definitions.type)\n\n        self.visit_sequence(node.body)\n        self._func_return_names.pop()\n</code></pre> <p>Most of the code here is about handling this weird \"assign to function's name to define the return value\" behaviour. Honestly, I don't know how to handle this better, so here we go: we keep a stack of <code>(return_type, function_name)</code> pairs, which we'll use later to resolve <code>lvalue</code>s. At the very end we simply pop this pair from the stack.</p> <p>The rest is pretty straightforward. Define the variables, don't forget about function arguments (which are also a kind of local variables) then visit each statement in the body.</p>"},{"location":"blog/2023/10/08/pascal-llvm-3/#assignment","title":"Assignment","text":"<p>This is one of our main nodes. Assignments are the bridge between <code>lvalues</code> and <code>rvalues</code>:</p> <pre><code>def _assignment(self, node: Assignment):\n    kind = self.visit(node.target, expected=None, lvalue=True)\n    # no need to cast to reference in this case\n    if isinstance(kind, types.Reference):\n        kind = kind.type\n\n    self.visit(node.value, expected=kind, lvalue=False)\n</code></pre> <p>First, we get the type of the left side. Here <code>expected</code> is <code>None</code> because don't care which type we're going to store in, we only care <code>what</code> we'll store there. That's why we visit the right side by passing the type constraint that we received from the left side.</p> <p>Additionally, we unwrap the potential <code>Reference</code> here: writing to a reference is the same as writing to a regular  variable, at least from type system's perspective.</p>"},{"location":"blog/2023/10/08/pascal-llvm-3/#const","title":"Const","text":"<p>What's the type of a <code>Const</code> node? Simple! We already stored the type while parsing:</p> <pre><code>def _const(self, node: Const, expected: types.DataType, lvalue: bool):\n    if lvalue:\n        raise WrongType(node)\n    return node.type\n</code></pre> <p>additionally we make sure here that we're not trying to assign anything to this node, i.e. it's an <code>rvalue</code>.</p>"},{"location":"blog/2023/10/08/pascal-llvm-3/#name","title":"Name","text":"<p>Here comes the moment of truth, this little method handles all the references to variables and functions</p> <pre><code>def _name(self, node: Name, expected: types.DataType, lvalue: bool):\n    # assignment to the function's name inside a function is definition of a return value\n    if lvalue and self._func_return_names:\n        kind, target = self._func_return_names[-1]\n        if kind != types.Void and target.name == node.name:\n            self._bind(node, target)\n            return kind\n\n    kind, target = self._resolve(node.normalized)\n    if isinstance(kind, types.Function):\n        self.desugar[node] = new = Call(node, ())\n        return self._call(new, expected, lvalue)\n\n    self._bind(node, target)\n    return kind\n</code></pre> <p>First we handle our ugly \"assign to function name\" case. We do this only if</p> <ul> <li>it's an <code>lvalue</code></li> <li>we're inside a function i.e. <code>_func_return_names</code> isn't empty</li> <li>we're inside a non-Void function (not a procedure), so the return type isn't <code>Void</code></li> <li>the name we're referring to is the same as the function's name</li> </ul> <p>If all these conditions are met, we <code>bind</code> the current node to the function's return value.</p> <p>Otherwise, we <code>resolve</code> the name and just <code>bind</code> it to the variable we found.</p> <p>Finally, there's one more case we need to handle. As we saw before, you can call functions with 0 arguments without parentheses. This is 100% legal:</p> <pre><code>program legal;\nbegin\n    writeln;\nend.\n</code></pre> <p>Looks like in the 70s programmers liked syntactic sugar  even more than we do today.</p> <p>That's why we do another check - if it's a function then it's actually a function call, and we need to replace the current node with a <code>Call(node, ())</code> - we desugar it and store this info to help the compiler.</p>"},{"location":"blog/2023/10/08/pascal-llvm-3/#call","title":"Call","text":"<pre><code>def _call(self, node: Call, expected: types.DataType, lvalue: bool):\n    if not isinstance(node.target, Name):\n        raise WrongType(node)\n\n    # get all the functions with this name\n    kind, targets = self._resolve(node.target.normalized)\n    if not isinstance(kind, types.Function):\n        raise WrongType(kind)\n\n    # choose the right function\n    signature = self._dispatch(node.args, kind.signatures, expected)\n    self._bind(node.target, targets[signature])\n    return signature.return_type\n</code></pre> <p>Handling calls is pretty straightforward: </p> <ol> <li>take the <code>target</code>, which must be a <code>Name</code>, functions aren't  first class citizens in Pascal!</li> <li><code>resolve</code> the name and make sure we've found a function</li> <li>if it's an overloaded function, choose the right variant based on the signatures (static dispatch)</li> <li><code>bind</code> the <code>Name</code> node to the function we just chose</li> </ol> <p>All the heavy lifting is done in our <code>_dispatch</code> function:</p> <pre><code>def _dispatch(self, args: Sequence, signatures: Sequence[types.Signature], expected: types.DataType):\n    for signature in signatures:\n        if len(signature.args) != len(args):\n            continue\n        if not self.can_cast(signature.return_type, expected):\n            continue\n\n        try:\n            for arg, kind in zip(args, signature.args, strict=True):\n                if isinstance(kind, types.Reference) and not isinstance(arg, Name):\n                    raise WrongType('Only variables can be mutable arguments')\n\n                self.visit(arg, expected=kind, lvalue=False)\n\n        except WrongType:\n            continue\n\n        return signature\n\n    raise WrongType(args, expected, signatures)\n</code></pre> <p>Also pretty simple, just loop over all the signatures we have and try to find a match based on the number of <code>args</code>, their types, and the <code>expected</code> return type of the function. We also check along the way, that if an argument is  mutable we can only pass a variable to it.</p> <p>In the end we just fail with a <code>WrongType</code> if nothing was found.</p>"},{"location":"blog/2023/10/08/pascal-llvm-3/#dereference","title":"Dereference","text":"<p>We're done with the hard part! The rest should be a piece of cake:</p> <pre><code>def _dereference(self, node: Dereference, expected: types.DataType, lvalue: bool):\n    target = self.visit(node.target, types.Pointer(expected), lvalue)\n    return target.type\n</code></pre> <p>visit the <code>target</code> while expecting a pointer, then return the type we point to.</p>"},{"location":"blog/2023/10/08/pascal-llvm-3/#getfield","title":"GetField","text":"<p>More or less the same here:</p> <pre><code>def _get_field(self, node: GetField, expected: types.DataType, lvalue: bool):\n    target = self.visit(node.target, expected=None, lvalue=False)\n    if isinstance(target, types.Reference):\n        target = target.type\n    if not isinstance(target, types.Record):\n        raise WrongType(target)\n\n    for field in target.fields:\n        if field.name == node.name:\n            return field.type\n\n    raise WrongType(target, node.name)\n</code></pre> <p>Visit the target, make sure we've got a record, find the right field by name and return its type.</p>"},{"location":"blog/2023/10/08/pascal-llvm-3/#getitem","title":"GetItem","text":"<p>And here as well:</p> <pre><code>def _get_item(self, node: GetItem, expected: types.DataType, lvalue: bool):\n    target = self.visit(node.target, expected=None, lvalue=True)\n    if isinstance(target, types.Reference):\n        target = target.type\n    if not isinstance(target, (types.StaticArray, types.DynamicArray)):\n        raise WrongType(target)\n\n    ndims = len(target.dims) if isinstance(target, types.StaticArray) else 1\n    if len(node.args) != ndims:\n        raise WrongType(target, node.args)\n\n    args = self.visit_sequence(node.args, expected=types.Integer, lvalue=False)\n    args = [x.type if isinstance(x, types.Reference) else x for x in args]\n    if not all(isinstance(x, types.SignedInt) for x in args):\n        raise WrongType(node)\n\n    return target.type\n</code></pre> <p>The only difference is that arrays can have multiple indices and we must check that each index is an integer.</p>"},{"location":"blog/2023/10/08/pascal-llvm-3/#unary","title":"Unary","text":"<p>Pascal doesn't have many unary operators:</p> <pre><code>def _unary(self, node: Unary, expected: types.DataType, lvalue: bool):\n    if node.op == '@':\n        if not isinstance(expected, types.Pointer) or lvalue:\n            raise WrongType(node)\n        return types.Pointer(self.visit(node.value, expected=expected.type, lvalue=lvalue))\n\n    return self.visit(node.value, expected, lvalue)\n</code></pre> <p>In case of taking an address (<code>@</code>) we check that it's not an <code>lvalue</code> and that we're expected to return a <code>Pointer</code>. The rest are just <code>+</code>, <code>-</code> and <code>not</code>, which all return the same type as their argument, so we just visit the <code>value</code>  with the same arguments.</p>"},{"location":"blog/2023/10/08/pascal-llvm-3/#binary","title":"Binary","text":"<p>Binary operators, as always, are a bit more interesting. There's a lot of type casting going on with them, e.g. we want to easily add a <code>Real</code> to an <code>Integer</code>, which makes perfect sense in most situations.</p> <p>For me the simplest solution is to treat binary operators as simple functions with 2 arguments. We'll create a  collection of such functions and use our <code>_dispatch</code> method to do all the work:</p> <pre><code>_numeric = [*types.Ints, *types.Floats]\n_homogeneous = {\n    '+': _numeric,\n    '*': _numeric,\n    '-': _numeric,\n    '/': _numeric,\n    'and': [types.Boolean],\n    'or': [types.Boolean],\n}\n_boolean = {\n    '=': _numeric,\n    '&lt;': _numeric,\n    '&lt;=': _numeric,\n    '&gt;': _numeric,\n    '&gt;=': _numeric,\n    '&lt;&gt;': _numeric,\n}\nBINARY_SIGNATURES = {\n    k: [types.Signature((v, v), v) for v in vs]\n    for k, vs in _homogeneous.items()\n}\nBINARY_SIGNATURES.update({\n    k: [types.Signature((v, v), types.Boolean) for v in vs]\n    for k, vs in _boolean.items()\n})\n</code></pre> <p>I'm writing from memory here, so I might be wrong, but I'm pretty sure all the operators either return the same type they received, or a <code>Boolean</code> in case of logical operators. That's what the code from above does: it synthetically  generates a number of valid signatures for binary operators. So the <code>_binary</code> method itself becomes as easy as:</p> <pre><code>def _binary(self, node: Binary, expected: types.DataType, lvalue: bool):\n    return self._dispatch([node.left, node.right], BINARY_SIGNATURES[node.op], expected).return_type\n</code></pre> <p>Not bad at all </p>"},{"location":"blog/2023/10/08/pascal-llvm-3/#expression-statement","title":"Expression statement","text":"<p>We're done with expressions! Now to statements. </p> <pre><code>def _expression_statement(self, node: ExpressionStatement):\n    self.visit(node.value, expected=None, lvalue=False)\n</code></pre> <p>Super simple, just visit the expression, don't even care what's the return type.</p>"},{"location":"blog/2023/10/08/pascal-llvm-3/#if","title":"If","text":"<pre><code>def _if(self, node: If):\n    self.visit(node.condition, expected=types.Boolean, lvalue=False)\n    self.visit_sequence(node.then_)\n    self.visit_sequence(node.else_)\n</code></pre> <p>We visit the condition making sure it's <code>Boolean</code>. Then we unconditionally visit both branches. This contrasts with how <code>If</code> is evaluated at runtime. For now we're only interested in variables resolution and expression types, so we must visit both branches.</p>"},{"location":"blog/2023/10/08/pascal-llvm-3/#while","title":"While","text":"<pre><code>def _while(self, node: While):\n    self.visit(node.condition, expected=types.Boolean, lvalue=False)\n    self.visit_sequence(node.body)\n</code></pre> <p>Almost same thing here.</p>"},{"location":"blog/2023/10/08/pascal-llvm-3/#for","title":"For","text":"<p>And the final node:</p> <pre><code>def _for(self, node: For):\n    counter = self.visit(node.name, expected=None, lvalue=True)\n    if not isinstance(counter, types.SignedInt):\n        raise WrongType(counter)\n\n    self.visit(node.start, expected=counter, lvalue=False)\n    self.visit(node.stop, expected=counter, lvalue=False)\n    self.visit_sequence(node.body)\n</code></pre> <p><code>For</code> has a counter variable which we assign values to, and it must be an integer. In rest, this is just a combination of <code>If</code> and <code>While</code>, nothing new.</p>"},{"location":"blog/2023/10/08/pascal-llvm-3/#casting-rules","title":"Casting rules","text":"<p>As I promised, here's the <code>can_cast</code> method, that handles all type casting:</p> <pre><code>def can_cast(self, kind: types.DataType, to: types.DataType) -&gt; bool:\n    # we either don't care (to is None) or they're both the same type\n    if to is None or kind == to:\n        return True\n\n    match kind, to:\n        # references are just a wrapper, so we'll ignore them\n        case types.Reference(src), _:\n            return self.can_cast(src, to)\n        case _, types.Reference(dst):\n            return self.can_cast(kind, dst)\n\n        # static arrays can be viewed as dynamic in some cases, if they're 1-dimensional\n        case types.StaticArray(dims, src), types.DynamicArray(dst):\n            return len(dims) == 1 and src == dst\n\n        # ints can be cast to floats\n        case types.SignedInt(_), types.Floating(_):\n            return True\n\n    # basic upcasting, e.g. Byte -&gt; Integer\n    for family in types.SignedInt, types.Floating:\n        if isinstance(kind, family) and isinstance(to, family):\n            return kind.bits &lt;= to.bits\n\n    # no luck\n    return False\n</code></pre> <p>I added comments to the relevant parts, so this should be pretty straightforward.</p>"},{"location":"blog/2023/10/08/pascal-llvm-3/#a-bit-of-magic","title":"A bit of magic","text":"<p>Finally, there's one more important bit that we need to talk about: <code>writeln</code>. </p> <p>It turns out that Pascal does a bit of cheating, and exposes several magic functions, that can't be implemented in the language itself. The most known of them is <code>writeln</code>: it can accept  any number of arguments and each of them can have any type from a  long list of allowed types. So, once again, this is 100% legal:</p> <pre><code>writeln;\nwriteln(1);\nwriteln(1, 2.5);\nwriteln(1, 2.5, 'my string');\n</code></pre> <p>There is simply no way for us to try and squeeze this behaviour into our <code>_dispatch</code> method, in a way, <code>writeln</code> is  an infinite number of overloaded functions.</p> <p>To do this we'll introduce a new concept:</p> <pre><code>from abc import ABC, abstractmethod\n\nclass MagicFunction(ABC):\n    @classmethod\n    @abstractmethod\n    def validate(cls, args, visit) -&gt; DataType:\n        pass\n</code></pre> <p>Yes, at this point we could replace this class with a function, but we'll extend it later, so introducing a new type is super legit, I promise!</p> <p><code>validate</code> will have to, wait for it, validate the incoming arguments and decide the return type of the function. In case of <code>writeln</code> this should look like so:</p> <pre><code>class WriteLn(MagicFunction):\n    @classmethod\n    def validate(cls, args, visit) -&gt; DataType:\n        for arg in args:\n            # we can write ~almost~ anything, so we don't care about the type\n            visit(arg, None, False)\n        return types.Void\n</code></pre> <p>and there are a few places we'll need to add support for it, but first, let's create a registry of magic functions:</p> <pre><code>MAGIC_FUNCTIONS = {\n    'writeln': WriteLn,\n}\n</code></pre>"},{"location":"blog/2023/10/08/pascal-llvm-3/#program_1","title":"Program","text":"<p>As soon as we enter the global scope, we must define all the magic functions:</p> <pre><code>def _program(self, node: Program):\n    with self._enter():\n        # magic\n        for name, magic in MAGIC_FUNCTIONS.items():\n            self._store(name, magic(), None)\n\n        # ... the rest\n</code></pre>"},{"location":"blog/2023/10/08/pascal-llvm-3/#call_1","title":"Call","text":"<p>Next, calling magic functions needs special treatment:</p> <pre><code>def _call(self, node: Call, expected: types.DataType, lvalue: bool):\n    if not isinstance(node.target, Name):\n        raise WrongType(node)\n\n    # get all the functions with this name\n    kind, targets = self._resolve(node.target.normalized)\n    if isinstance(kind, MagicFunction):\n        return kind.validate(node.args, self.visit)\n\n    # ... the rest\n</code></pre>"},{"location":"blog/2023/10/08/pascal-llvm-3/#name_1","title":"Name","text":"<p>And finally, we should desugar 0-arg calls:</p> <pre><code># replace\nif isinstance(kind, types.Function):\n\n# by\nif isinstance(kind, (types.Function, MagicFunction)):\n</code></pre> <p>That's it! Now we have a real-life type system. This took a while, but I hope you found something useful.</p> <p>You probably noticed that this is already the third post in this series, and still there's no LLVM in sight. In the  next and final post we'll fix that. Next time we'll use all the concepts we built so far to compile everything to  LLVM's IR!</p>"},{"location":"blog/2023/10/13/pascal-llvm-4/","title":"Compiling Pascal with LLVM: Part 4","text":""},{"location":"blog/2023/10/13/pascal-llvm-4/#compilation","title":"Compilation","text":"<p>It took several hundreds of lines of code, but we're finally there! Today our compiler will come to life and finally compute something for us.</p>"},{"location":"blog/2023/10/13/pascal-llvm-4/#a-working-prototype","title":"A working prototype","text":"<p>Let's start small and build a compiler that works with something super dumb:</p> <pre><code>program add;\nbegin\n    1 + 1;\nend.\n</code></pre> <p>We'll start with that, and work our way up. Here's our compiler class:</p> <pre><code>from llvmlite import ir\n\n\nclass Compiler(Visitor):\n    def __init__(self, ts: TypeSystem):\n        self.module = ir.Module()\n        self._builders = []\n\n        self._ts = ts\n        self._references = ts.references\n        # for allocated variables\n        self._allocas = {}\n        # for functions and strings deduplication\n        self._function_names = {}\n        self._string_idx = 0\n</code></pre> <p>As always, let's <code>visit</code> the program first:</p> <pre><code>def _program(self, node: Program):\n    main = ir.Function(self.module, ir.FunctionType(ir.VoidType(), ()), '.main')\n\n    with self._enter(main):\n        self.visit_sequence(node.body)\n        self.builder.ret_void()\n</code></pre> <p>Here <code>_enter</code> is more ore less the same as in our type system:</p> <pre><code>@contextmanager\ndef _enter(self, func):\n    self._builders.append(ir.IRBuilder(func.append_basic_block()))\n    yield\n    self._builders.pop()\n</code></pre> <p>and <code>self.builder</code> is just a property:</p> <pre><code>@property\ndef builder(self) -&gt; ir.IRBuilder:\n    return self._builders[-1]\n</code></pre> <p>In LLVM each function wants a separate IRBuilder, think of it as a storage for all the statements in the function's body.</p> <p>Even though there isn't a <code>main</code> function in Pascal as in <code>C</code>, LLVM can't just run stuff \"in the global scope\", so we have to create here a <code>.main</code> function. I chose this name, because it's not a valid function name in Pascal, so we won't have name collisions.</p> <p>For now this function is pretty simple. It has no arguments, neither variables, it just goes through the statements and return <code>Void</code> at the end.</p>"},{"location":"blog/2023/10/13/pascal-llvm-4/#expression-statement","title":"Expression statement","text":"<p>As I quickly mentioned in the previous post, we'll expect from <code>lvalues</code> to return a pointer. This will be the signature of methods that deal with values:</p> <pre><code>def _my_node(self, node, lvalue: bool):\n    # ...\n</code></pre> <p>Now we don't need the \"<code>expected</code>\" argument, because all the information regarding types is already present.</p> <p>So, for expression statements the code is fairly simple:</p> <pre><code>def _expression_statement(self, node: ExpressionStatement):\n    self.visit(node.value, lvalue=False)\n</code></pre>"},{"location":"blog/2023/10/13/pascal-llvm-4/#const","title":"Const","text":"<p>Let's keep digging through the simple stuff first. Here's how we evaluate integer and floating constants:</p> <pre><code>def _const(self, node: Const, lvalue: bool):\n    value = node.value\n    match node.type:\n        case types.SignedInt(_) | types.Floating(_) as kind:\n            return ir.Constant(resolve(kind), value)\n\n        # ... more cases later\n\n    raise ValueError(value)\n</code></pre> <p>Here <code>resolve</code> is the bridge between our own type system and the one from LLVM:</p> <pre><code>def resolve(kind):\n    match kind:\n        case types.Void:\n            return ir.VoidType()\n        case types.Char:\n            return ir.IntType(8)\n        case types.SignedInt(bits):\n            return ir.IntType(bits)\n        case types.Floating(64):\n            return ir.DoubleType()\n        case types.Reference(kind) | types.Pointer(kind) | types.DynamicArray(kind):\n            return ir.PointerType(resolve(kind))\n        case types.StaticArray(dims, kind):\n            size = reduce(mul, [b - a for a, b in dims], 1)\n            return ir.ArrayType(resolve(kind), size)\n        case types.Record(fields):\n            return ir.LiteralStructType([resolve(field.type) for field in fields])\n\n    raise ValueError(kind)\n</code></pre> <p>As we can see, LLVM's type system is much simpler, e.g. arrays are only 1-dimensional and start always at 0 also there are no references or dynamic arrays, just pointers.</p>"},{"location":"blog/2023/10/13/pascal-llvm-4/#binary","title":"Binary","text":"<p>Once again, binary operators are a headache:</p> <pre><code>def _binary(self, node: Binary, lvalue: bool):\n    left = self.visit(node.left, lvalue)\n    right = self.visit(node.right, lvalue)\n    kind = self._type(node.left)\n    right_kind = self._type(node.right)\n    assert kind == right_kind, (kind, right_kind)\n\n    match kind:\n        case types.SignedInt(_):\n            if node.op in COMPARISON:\n                return self.builder.icmp_signed(COMPARISON[node.op], left, right)\n            return {\n                '+': self.builder.add,\n                '-': self.builder.sub,\n                '*': self.builder.mul,\n                '/': self.builder.sdiv,\n            }[node.op](left, right)\n\n        case types.Floating(_):\n            if node.op in COMPARISON:\n                return self.builder.fcmp_ordered(COMPARISON[node.op], left, right)\n            return {\n                '+': self.builder.fadd,\n                '-': self.builder.fsub,\n                '*': self.builder.fmul,\n                '/': self.builder.fdiv,\n            }[node.op](left, right)\n\n        case types.Boolean:\n            return {\n                'and': self.builder.and_,\n                'or': self.builder.or_,\n            }[node.op](left, right)\n\n        case x:\n            raise TypeError(x)\n</code></pre> <p>We visit the left and right operand, and make sure they have the same type, which must be true after type casting. Here's how we get the type of a node:</p> <pre><code>def _type(self, node):\n    if node in self._ts.casting:\n        return self._ts.casting[node]\n    return self._ts.types[node]\n</code></pre> <p>Quick reminder: self._ts is an instance of the TypeSystem class, which already analyzed our program.</p> <p>Then, based on the type we choose from the multitude of LLVM's operators. Logical operators get special treatment, because of how they are represented in Pascal:</p> <pre><code>COMPARISON = {\n    '&lt;': '&lt;',\n    '&lt;=': '&lt;=',\n    '&gt;': '&gt;',\n    '&gt;=': '&gt;=',\n    '=': '==',\n    '&lt;&gt;': '!=',\n}\n</code></pre> <p>We need this mapping to simplify the conversion from <code>&lt;&gt;</code> to the modern globally accepted <code>!=</code>.</p>"},{"location":"blog/2023/10/13/pascal-llvm-4/#running-the-code","title":"Running the code","text":"<p>Now we can finally run our stupid program! We'll need to set a few things up first:</p> <pre><code>import ctypes\n\nimport llvmlite.binding as llvm\n\nfrom pascal_llvm.compiler import Compiler\nfrom pascal_llvm.parser import Parser\nfrom pascal_llvm.tokenizer import tokenize\nfrom pascal_llvm.type_system import TypeSystem\n\nsource = '''\nprogram add;\nbegin\n    1 + 1;\nend.\n'''\n# scan and parse\ntokens = tokenize(source)\nparser = Parser(tokens)\nprogram = parser._program()\n# add types\nts = TypeSystem()\nts.visit(program)\n# compile\ncompiler = Compiler(ts)\ncompiler.visit(program)\nmodule = compiler.module\n# translate\nmodule = llvm.parse_assembly(str(module))\nmodule.verify()\n# init\nllvm.initialize()\nllvm.initialize_native_target()\nllvm.initialize_native_asmprinter()\ntarget = llvm.Target.from_default_triple()\nmachine = target.create_target_machine()\nengine = llvm.create_mcjit_compiler(llvm.parse_assembly(\"\"), machine)\n# load the code\nengine.add_module(module)\nengine.finalize_object()\nengine.run_static_constructors()\n# get the \".main\" function pointer\nmain = ctypes.CFUNCTYPE(None)(engine.get_function_address('.main'))\n# call it\nmain()\n</code></pre> <p>That's a lot of glue code. But it's reusable! From now on you can simply change the <code>source</code> and play around with the compiler as it gets smarter.</p> <p>At this point this will do basically nothing, but we could print LLVM's IR and see what it thinks of our code. Just call <code>print(module)</code>:</p> <pre><code>; ModuleID = \"\"\ntarget triple = \"unknown-unknown-unknown\"\ntarget datalayout = \"\"\n\ndefine void @\".main\"()\n{\n.2:\n  %\".3\" = add i8 1, 1\n  ret void\n}\n</code></pre> <p>Even if you're not familiar with the syntax, it's pretty clear what's happening here - a function definition, which adds two i8 (char) constants, stores them in a temporary variable and returns nothing. Just as we intended!</p> <p>If you expected LLVM to optimize out this useless <code>add</code> operation, you're totally right. We'll get to that later.</p>"},{"location":"blog/2023/10/13/pascal-llvm-4/#variables","title":"Variables","text":"<p>Our next milestone is adding variables and tons of code that works with them. First of all, let's define them:</p> <pre><code>def _program(self, node: Program):\n    for definitions in node.variables:\n        for name in definitions.names:\n            var = ir.GlobalVariable(self.module, resolve(definitions.type), name=name.normalized)\n            var.linkage = 'private'\n            self._allocas[name] = var\n\n    main = ir.Function(self.module, ir.FunctionType(ir.VoidType(), ()), '.main')\n    with self._enter(main):\n        self.visit_sequence(node.body)\n        self.builder.ret_void()\n</code></pre> <p>Nothing special, we create a global variable of a given type and store it in our <code>_allocas</code> dict. I'm not very familiar with use-cases for different linkage types, but here \"private\" is the way to go - this is basically a global variable private to this module.</p>"},{"location":"blog/2023/10/13/pascal-llvm-4/#name","title":"Name","text":"<p>Now that we can define variables, let's learn to get their values and pointers.</p> <p>Remember how in the previous post we resolved each <code>Name</code> node, and found out what it references? It's time to use this info:</p> <pre><code>def _name(self, node: Name, lvalue: bool):\n    target = self._references[node]\n    ptr = self._allocas[target]\n    if lvalue:\n        if isinstance(self._type(target), types.Reference):\n            ptr = self.builder.load(ptr)\n        return ptr\n    return self.builder.load(ptr)\n</code></pre> <p>We get the right pointer first, then dereference it if it's an <code>rvalue</code>, otherwise - just return the pointer. A special case are references, which are represented as pointers: when we write</p> <pre><code>procedure f(var x: integer);\nbegin\n    x := 1;\nend;\n</code></pre> <p>we pretend x is an integer, while under the hood it's a pointer. So, in <code>_allocas</code> we'll store a pointer to a pointer, that's why we need an additional dereferencing step.</p>"},{"location":"blog/2023/10/13/pascal-llvm-4/#dereference","title":"Dereference","text":"<p>Speaking of dereferencing:</p> <pre><code>def _dereference(self, node: Dereference, lvalue: bool):\n    # always expect a pointer, so lvalue=True\n    ptr = self.builder.load(self.visit(node.target, lvalue=True))\n    if lvalue:\n        return ptr\n    return self.builder.load(ptr)\n</code></pre> <p>More or less the same stuff.</p>"},{"location":"blog/2023/10/13/pascal-llvm-4/#unary","title":"Unary","text":"<p>While we're at it, the opposite operation - taking the address - is another unary operator:</p> <pre><code>def _unary(self, node: Unary, lvalue: bool):\n    # getting the address is a special case\n    if node.op == '@':\n        # just get the name's address\n        return self.visit(node.value, lvalue=True)\n\n    value = self.visit(node.value, lvalue)\n    match node.op:\n        case '-':\n            return self.builder.neg(value)\n        case 'not':\n            return self.builder.not_(value)\n        case x:\n            raise ValueError(x, node)\n</code></pre> <p><code>@</code> is, once again, a special case.</p>"},{"location":"blog/2023/10/13/pascal-llvm-4/#getfield","title":"GetField","text":"<p>LLVM's notion of structs is pretty simple, and is basically indistinguishable from tuples.</p> <pre><code>record\n    count: integer;\n    percentage: real;\nend;\n</code></pre> <p>This record will have the type <code>(i32, double)</code>. This means that we can't access fields by name, and must use integer  indices instead:</p> <pre><code>def _get_field(self, node: GetField, lvalue: bool):\n    ptr = self.visit(node.target, lvalue=True)\n    kind = self._type(node.target)\n    if isinstance(kind, types.Reference):\n        kind = kind.type\n    idx, = [i for i, field in enumerate(kind.fields) if field.name == node.name]\n    ptr = self.builder.gep(\n        ptr, [ir.Constant(ir.IntType(32), 0), ir.Constant(ir.IntType(32), idx)]\n    )\n    if lvalue:\n        return ptr\n    return self.builder.load(ptr)\n</code></pre> <p>We then use the <code>gep</code> (get element pointer) command to take the value at the right index in the \"tuple\".</p> <p>I have no idea why we must pass a list with <code>ir.Constant(ir.IntType(32), 0)</code> as the first element, but all the  examples I found do it this way. If you can enlighten me, please leave a comment at the bottom of the page </p>"},{"location":"blog/2023/10/13/pascal-llvm-4/#getitem","title":"GetItem","text":"<p>As we saw earlier, in the LLVM world there are only 1D arrays that start from 0. That's ok, we just need to figure out a way to flatten Pascal's arrays. There are many ways to do that, we'll use strides here, more or less in the same fashion as numpy does:</p> <pre><code>def _get_item(self, node: GetItem, lvalue: bool):\n    # we always want a pointer from the parent\n    ptr = self.visit(node.target, lvalue=True)\n    stride = 1\n    dims = self._type(node.target).dims\n    idx = ir.Constant(ir.IntType(32), 0)\n    for (start, stop), arg in reversed(list(zip(dims, node.args, strict=True))):\n        local = self.visit(arg, lvalue=False)\n        # upcast to i32\n        local = self._cast(local, self._type(arg), types.Integer, False)\n        # extract the origin\n        local = self.builder.sub(local, ir.Constant(ir.IntType(32), start))\n        # multiply by stride\n        local = self.builder.mul(local, ir.Constant(ir.IntType(32), stride))\n        # add to index\n        idx = self.builder.add(idx, local)\n        stride *= stop - start\n\n    ptr = self.builder.gep(ptr, [ir.Constant(ir.IntType(32), 0), idx])\n    if lvalue:\n        return ptr\n    return self.builder.load(ptr)\n</code></pre> <p>That's a lot of code, but basically this is what it does:</p> <pre><code>llvm_index = stride1 * (pascal_index1 - index_start1) + stride2 * (pascal_index2 - index_start2) + ...\n</code></pre> <p>This StackOverflow question has a great visualization of what's going on.</p>"},{"location":"blog/2023/10/13/pascal-llvm-4/#assignment","title":"Assignment","text":"<p>The final node that will allow us to modify the variables we just created is the assignment:</p> <pre><code>def _assignment(self, node: Assignment):\n    ptr = self.visit(node.target, lvalue=True)\n    value = self.visit(node.value, lvalue=False)\n    if isinstance(self._type(node.value), types.Reference):\n        value = self.builder.load(value)\n\n    self.builder.store(value, ptr)\n</code></pre> <p>Also pretty straightforward: get the value from the right, get the address from the left, store one in the other.</p>"},{"location":"blog/2023/10/13/pascal-llvm-4/#statements","title":"Statements","text":"<p>There aren't a lot of statements in Pascal, so let's dig through them quickly:</p>"},{"location":"blog/2023/10/13/pascal-llvm-4/#if","title":"If","text":"<p>LLVM reasons in blocks. A block is just a sequence of simple operations: no branching, no control flow or jumps. We just start with the first operation and finish with the last one.</p> <p>If we need to create a branch, though, we just do it between blocks:</p> <pre><code>def _if(self, node: If):\n    condition = self.visit(node.condition, lvalue=False)\n    then_block = self.builder.append_basic_block()\n    else_block = self.builder.append_basic_block()\n    merged_block = self.builder.append_basic_block()\n    self.builder.cbranch(condition, then_block, else_block)\n\n    # then\n    self.builder.position_at_end(then_block)\n    self.visit_sequence(node.then_)\n    self.builder.branch(merged_block)\n    # else\n    self.builder.position_at_end(else_block)\n    self.visit_sequence(node.else_)\n    self.builder.branch(merged_block)\n    # phi\n    self.builder.position_at_end(merged_block)\n</code></pre> <p>So here's what's going on. We create 3 blocks: two for <code>if</code>'s branches and one for the final block. We create a conditional branch first, this will let us jump to one of the blocks, then we compile each branch. Note that at the beginning of each branch we enter the corresponding block with <code>position_at_end</code>, and at the end we create an unconditional <code>branch</code> (basically a jump) to the final block.</p> <p>That's more or less how all control flow will be implemented.</p>"},{"location":"blog/2023/10/13/pascal-llvm-4/#while","title":"While","text":"<p><code>While</code> is, in a way, even simpler than <code>If</code>:</p> <pre><code>def _while(self, node: While):\n    check_block = self.builder.append_basic_block('check')\n    loop_block = self.builder.append_basic_block('for')\n    end_block = self.builder.append_basic_block('for-end')\n    self.builder.branch(check_block)\n\n    # check\n    self.builder.position_at_end(check_block)\n    condition = self.visit(node.condition, False)\n    self.builder.cbranch(condition, loop_block, end_block)\n\n    # loop\n    self.builder.position_at_end(loop_block)\n    self.visit_sequence(node.body)\n    self.builder.branch(check_block)\n\n    # exit\n    self.builder.position_at_end(end_block)\n</code></pre> <p>At each iteration we check the condition and make a conditional jump. Inside the loop we just compile the body and unconditionally jump back to the first block. This way we make create a loop. Easy!</p>"},{"location":"blog/2023/10/13/pascal-llvm-4/#for","title":"For","text":"<p>As always, <code>For</code> is just a combination of <code>While</code> and some increments.</p> <p>It makes you think, maybe we should have desugared this node in the previous post </p> <pre><code>def _for(self, node: For):\n    name = node.name\n    start = self.visit(node.start, lvalue=False)\n    stop = self.visit(node.stop, lvalue=False)\n    self._assign(name, start)\n\n    check_block = self.builder.append_basic_block('check')\n    loop_block = self.builder.append_basic_block('for')\n    end_block = self.builder.append_basic_block('for-end')\n    self.builder.branch(check_block)\n\n    # check\n    self.builder.position_at_end(check_block)\n    counter = self.visit(name, lvalue=False)\n    condition = self.builder.icmp_signed('&lt;=', counter, stop, 'for-condition')\n    self.builder.cbranch(condition, loop_block, end_block)\n\n    # loop\n    self.builder.position_at_end(loop_block)\n    self.visit_sequence(node.body)\n    # update\n    increment = self.builder.add(counter, ir.Constant(resolve(self._type(name)), 1), 'increment')\n    self._assign(name, increment)\n    self.builder.branch(check_block)\n\n    # exit\n    self.builder.position_at_end(end_block)\n</code></pre> <p>I guess only two pieces are interesting here:</p> <pre><code>start = self.visit(node.start, lvalue=False)\nself._assign(name, start)\n# and\nincrement = self.builder.add(counter, ir.Constant(resolve(self._type(name)), 1), 'increment')\nself._assign(name, increment)\n</code></pre> <p><code>_assign</code> is almost identical to <code>_assignment</code>:</p> <pre><code>def _assign(self, name: Name, value):\n    target = self._references[name]\n    ptr = self._allocas[target]\n    if isinstance(self._type(target), types.Reference):\n        ptr = self.builder.load(ptr)\n    self.builder.store(value, ptr)\n</code></pre> <p>As we can see, we're writing to the same variable twice, but LLVM is cool with that.</p>"},{"location":"blog/2023/10/13/pascal-llvm-4/#functions-and-calls","title":"Functions and calls","text":"<p>We're almost there!</p>"},{"location":"blog/2023/10/13/pascal-llvm-4/#function-definitions","title":"Function definitions","text":"<p>We'll define all the functions after defining the global variables but before the main body:</p> <pre><code>def _program(self, node: Program):\n    for definitions in node.variables:\n        for name in definitions.names:\n            var = ir.GlobalVariable(self.module, resolve(definitions.type), name=name.normalized)\n            var.linkage = 'private'\n            self._allocas[name] = var\n\n    # --- new stuff starts here ---\n    for func in node.functions:\n        ir.Function(\n            self.module, ir.FunctionType(resolve(func.return_type), [resolve(arg.type) for arg in func.args]),\n            self._deduplicate(func),\n        )\n    self.visit_sequence(node.functions)\n\n    main = ir.Function(self.module, ir.FunctionType(ir.VoidType(), ()), '.main')\n    with self._enter(main):\n        self.visit_sequence(node.body)\n        self.builder.ret_void()\n</code></pre> <p>Just like before, we first define all the functions, and only after that we visit each of their bodies.  Here <code>_deduplicate</code> helps us... uh... deduplicate the function names. Remember that we might have several overloaded  functions, LLVM can't digest that, so we need to help it a bit:</p> <pre><code>def _deduplicate(self, node: Function):\n    if node not in self._function_names:\n        self._function_names[node] = f'function.{len(self._function_names)}.{node.name.name}'\n    return self._function_names[node]\n</code></pre> <p>We create a new unique name for each function. It's a pretty dumb strategy, I admit, but it's dead simple (that's a good thing!). If I was writing a real compiler, I would add some info regarding argument names and the return value  instead, this would help a lot with debugging.</p>"},{"location":"blog/2023/10/13/pascal-llvm-4/#function","title":"Function","text":"<p>Now to the function itself. It's more or less the same thing as with the <code>Program</code>:</p> <pre><code>def _function(self, node: Function):\n    ret = node.name\n    func = self.module.get_global(self._deduplicate(node))\n    with self._enter(func):\n        if node.return_type != types.Void:\n            self._allocate(ret, resolve(node.return_type))\n\n        for arg, param in zip(func.args, node.args, strict=True):\n            name = param.name\n            arg.name = name.normalized\n            self._allocate(name, resolve(param.type), arg)\n\n        for definitions in node.variables:\n            for name in definitions.names:\n                self._allocate(name, resolve(definitions.type))\n\n        self.visit_sequence(node.body)\n\n        if node.return_type != types.Void:\n            self.builder.ret(self.builder.load(self._allocas[ret]))\n        else:\n            self.builder.ret_void()\n</code></pre> <ol> <li>Get the function</li> <li>Enter the scope</li> <li>Define the variables, the arguments and the return value, if any</li> <li>Visit the body</li> <li>Return</li> </ol> <p>The only difference is that we're not defining functions here, because Pascal doesn't support  closures.</p> <p>We define local variables like so:</p> <pre><code>def _allocate(self, name: Name, kind: ir.Type, initial=None):\n    self._allocas[name] = self.builder.alloca(kind, name=name.normalized)\n    if initial is not None:\n        self.builder.store(initial, self._allocas[name])\n</code></pre> <p><code>alloca</code> is LLVM's way to allocate a portion of memory.</p>"},{"location":"blog/2023/10/13/pascal-llvm-4/#call","title":"Call","text":"<p>We can define functions. Time to learn how to call them:</p> <pre><code>def _call(self, node: Call, lvalue: bool):\n    magic = MAGIC_FUNCTIONS.get(node.target.normalized)\n    if magic is not None:\n        return magic.evaluate(node.args, list(map(self._type, node.args)), self)\n\n    target = self._references[node.target]\n    func = self.module.get_global(self._deduplicate(target))\n    signature = target.signature\n\n    args = []\n    for arg, kind in zip(node.args, signature.args, strict=True):\n        if isinstance(kind, types.Reference):\n            value = self._allocas[self._references[arg]]\n        else:\n            value = self.visit(arg, lvalue=False)\n        args.append(value)\n\n    return self.builder.call(func, args)\n</code></pre> <p>If we ignore the magical part, this should be straightforward: </p> <ol> <li>Find the function by its name</li> <li>Compute the arguments</li> <li>Call the function with these arguments</li> </ol> <p>We only have a small hiccup with (2): if it's a mutable argument - we know for sure it's a variable (we checked for that in the previous post), so we can get its address directly from the <code>_allocas</code>.</p> <p>Now what about those first three lines? They deserve a separate section!</p>"},{"location":"blog/2023/10/13/pascal-llvm-4/#even-more-magic","title":"Even more magic","text":"<p>Previously we learned how to validate the arguments of magic functions. Now let's figure out how to evaluate them. We'll extend the interface with another method:</p> <pre><code>class MagicFunction(ABC):\n    @classmethod\n    @abstractmethod\n    def validate(cls, args, visit) -&gt; types.DataType:\n        pass\n\n    @classmethod\n    @abstractmethod\n    def evaluate(cls, args, kinds, compiler):\n        pass\n</code></pre> <p>and this is how <code>WriteLn</code> would implement it:</p> <pre><code>class WriteLn(MagicFunction):\n    @classmethod\n    def validate(cls, args, visit) -&gt; types.DataType:\n        for arg in args:\n            visit(arg, None, False)\n        return types.Void\n\n    @classmethod\n    def evaluate(cls, args, kinds, compiler):\n        ptr = compiler.string_pointer(format_io(kinds) + b'\\n\\00')\n        return compiler.builder.call(compiler.module.get_global('printf'), [ptr, *compiler.visit_sequence(args, False)])\n</code></pre> <p>We're basically preparing arguments for printf - a function from the C world.  It expects a format spec that depends on argument types:</p> <pre><code>from jboc import composed\n\n@composed(b' '.join)\ndef format_io(args):\n    for arg in args:\n        match arg:\n            case types.SignedInt(_):\n                yield b'%d'\n            case types.Floating(_):\n                yield b'%f'\n            case types.Char:\n                yield b'%c'\n            case types.StaticArray(dims, types.Char) if len(dims) == 1:\n                yield b'%s'\n            case types.DynamicArray(types.Char):\n                yield b'%s'\n            case kind:\n                raise TypeError(kind)\n</code></pre> <p>We then just find <code>printf</code> and call it. But to find it we first need to define it. We'll store all the definitions for external functions here:</p> <pre><code>FFI = {\n    'printf': ir.FunctionType(ir.IntType(32), [ir.IntType(8).as_pointer()], var_arg=True),\n    'scanf': ir.FunctionType(ir.IntType(32), [ir.IntType(8).as_pointer()], var_arg=True),\n    'getchar': ir.FunctionType(ir.IntType(8), []),\n    'rand': ir.FunctionType(ir.IntType(32), []),\n    'srand': ir.FunctionType(ir.VoidType(), [ir.IntType(32)]),\n    'time': ir.FunctionType(ir.IntType(32), [ir.IntType(32)]),\n}\n</code></pre> <p>FFI stands for foreign function interface</p> <p>I defined a bunch of them just in case. Note that <code>printf</code> and <code>scanf</code> are variadic, just like <code>writeln</code> and <code>readln</code>  in Pascal.</p> <p>Finally, we'll add these definitions in <code>Compiler</code>'s constructor:</p> <pre><code>def __init__(self, ts: TypeSystem):\n    # ... other stuff\n\n    for name, kind in FFI.items():\n        ir.Function(self.module, kind, name)\n</code></pre> <p>Wait. What's with that <code>string_pointer</code> function? We need to pass a pointer to the spec string to <code>printf</code>. Here's the  solution I came up with. We'll make compile-time string global constants like so:</p> <pre><code>def string_pointer(self, value: bytes):\n    kind = ir.ArrayType(ir.IntType(8), len(value))\n    global_string = ir.GlobalVariable(self.module, kind, name=f'string.{self._string_idx}.global')\n    global_string.global_constant = True\n    global_string.initializer = ir.Constant(kind, [ir.Constant(ir.IntType(8), x) for x in value])\n    self._string_idx += 1\n    return self.builder.gep(\n        global_string, [ir.Constant(ir.IntType(32), 0), ir.Constant(ir.IntType(32), 0)]\n    )\n</code></pre> <p>We create a global variable with a unique name, <code>_string_idx</code> makes sure of that. We initialize it with our string,  then we take its pointer and return it.</p> <p>With this code in place, we can also add another branch to <code>_const</code>:</p> <pre><code>def _const(self, node: Const, lvalue: bool):\n    value = node.value\n    match node.type:\n        case types.StaticArray(dims, types.Char) if len(dims) == 1:\n            return self.string_pointer(value)\n        # ... rest of the cases\n</code></pre>"},{"location":"blog/2023/10/13/pascal-llvm-4/#read","title":"Read","text":"<p>I'll show you a few more implementations real quick:</p> <pre><code>class Read(MagicFunction):\n    @classmethod\n    def validate(cls, args, visit) -&gt; types.DataType:\n        if not args:\n            raise WrongType\n\n        for arg in args:\n            visit(arg, None, True)\n        return types.Void\n\n    @classmethod\n    def evaluate(cls, args, kinds, compiler):\n        ptr = compiler.string_pointer(format_io(kinds) + b'\\00')\n        return compiler.builder.call(compiler.module.get_global('scanf'), [ptr, *compiler.visit_sequence(args, True)])\n</code></pre> <p>For <code>Read</code> we simply call into <code>scanf</code> instead of <code>printf</code>.</p>"},{"location":"blog/2023/10/13/pascal-llvm-4/#readln","title":"ReadLn","text":"<p>Now <code>ReadLn</code> is a totally different beast:</p> <pre><code>class ReadLn(MagicFunction):\n    @classmethod\n    def validate(cls, args, visit) -&gt; types.DataType:\n        for arg in args:\n            visit(arg, None, True)\n        return types.Void\n\n    @classmethod\n    def evaluate(cls, args, kinds, compiler):\n        builder = compiler.builder\n        ptr = compiler.string_pointer(format_io(kinds) + b'\\00')\n        builder.call(compiler.module.get_global('scanf'), [ptr, *compiler.visit_sequence(args, True)])\n        # ignore the rest of the line: while (getchar() != '\\n') {} // ord('\\n') == 10\n        check_block = builder.append_basic_block('check')\n        loop_block = builder.append_basic_block('loop')\n        end_block = builder.append_basic_block('end')\n        builder.branch(check_block)\n        # check\n        builder.position_at_end(check_block)\n        condition = builder.icmp_signed(\n            '!=', builder.call(compiler.module.get_global('getchar'), ()), ir.Constant(ir.IntType(8), 10)\n        )\n        builder.cbranch(condition, loop_block, end_block)\n        # loop\n        builder.position_at_end(loop_block)\n        builder.branch(check_block)\n        # exit\n        builder.position_at_end(end_block)\n</code></pre> <p>We first read several values, then we must skip the rest until we hit the line end. All the wizardry here is just translating this C code:</p> <pre><code>scanf(...);\nwhile (getchar() != '\\n') {}\n</code></pre>"},{"location":"blog/2023/10/13/pascal-llvm-4/#final-preparations","title":"Final preparations","text":"<p>Let's deal quickly with the boring stuff.</p>"},{"location":"blog/2023/10/13/pascal-llvm-4/#type-casting","title":"Type casting","text":"<p>Just like before, all type casting is happening in <code>after_visit</code>:</p> <pre><code>def _cast(self, value, src: types.DataType, dst: types.DataType, lvalue: bool):\n    # references are just fancy pointers\n    if isinstance(src, types.Reference) and not lvalue:\n        src = src.type\n        value = self.builder.load(value)\n\n    if src == dst:\n        return value\n\n    match src, dst:\n        case types.SignedInt(_), types.Floating(_):\n            return self.builder.sitofp(value, resolve(dst))\n        case types.SignedInt(_), types.SignedInt(_):\n            return self.builder.sext(value, resolve(dst))\n        case types.StaticArray(_), types.DynamicArray(_):\n            return value\n        # ... more cases here perhaps\n\n    raise NotImplementedError(value, src, dst)\n\n\ndef after_visit(self, node, value, lvalue=None):\n    if node in self._ts.casting:\n        assert lvalue is not None\n        return self._cast(value, self._ts.types[node], self._ts.casting[node], lvalue)\n    return value\n</code></pre>"},{"location":"blog/2023/10/13/pascal-llvm-4/#desugaring","title":"Desugaring","text":"<p>To write this one we'll need to extend the <code>Visitor</code> interface:</p> <pre><code>class Visitor:\n    def visit(self, node, *args, **kwargs):\n        node = self.before_visit(node, *args, **kwargs)\n        value = getattr(self, f'_{snake_case(type(node).__name__)}')(node, *args, **kwargs)\n        value = self.after_visit(node, value, *args, **kwargs)\n        return value\n\n    def before_visit(self, node, *args, **kwargs):\n        return node\n\n    # ... other methods\n</code></pre> <p>So, before visiting the node, we can change it and force the compiler to visit something else - perfect for  desugaring.</p> <p>And that's how the <code>Compiler</code> will implement it:</p> <pre><code>def before_visit(self, node, *args, **kwargs):\n    return self._ts.desugar.get(node, node)\n</code></pre> <p><code>d.get(x, x)</code> is just a quicker way to write <code>d[x] if x in d else x</code></p>"},{"location":"blog/2023/10/13/pascal-llvm-4/#magic-registry","title":"Magic registry","text":"<p>Last time we stored all our magic functions in a dict:</p> <pre><code>MAGIC_FUNCTIONS = {\n    'writeln': WriteLn,\n}\n</code></pre> <p>For 2-3 functions this is fine, but it quickly becomes tedious. Here's a cool way to do this automatically:</p> <pre><code>class MagicFunction(ABC):\n    # ... other methods\n\n    def __init_subclass__(cls, **kwargs):\n        name = cls.__name__.lower()\n        assert name not in MAGIC_FUNCTIONS\n        MAGIC_FUNCTIONS[name] = cls\n</code></pre> <p><code>__init_subclass__</code> is a hook that is triggered right after a new subclass is created, you get the idea.</p>"},{"location":"blog/2023/10/13/pascal-llvm-4/#optimization","title":"Optimization","text":"<p>At this point you should be able to finally print \"Hello world!\":</p> <pre><code>program main;\nbegin\n    writeln('Hello World!');\nend.\n</code></pre> <p>But there's more we can do! An obvious strong side of LLVM is optimization - it has a lot of different optimizations. Today we'll just a few of them that seem self-explanatory:</p> <pre><code># ....\n# translate\nmodule = llvm.parse_assembly(str(module))\nmodule.verify()\n\n# optimize\npm_builder = llvm.PassManagerBuilder()\npm = llvm.ModulePassManager()\npm_builder.populate(pm)\n# add passes\npm.add_constant_merge_pass()\npm.add_instruction_combining_pass()\npm.add_reassociate_expressions_pass()\npm.add_gvn_pass()\npm.add_cfg_simplification_pass()\npm.add_loop_simplification_pass()\npm.run(module)\n\n# run\nllvm.initialize()\n# ...\n</code></pre> <p>The pass manager <code>pm</code> will do all the heavy lifting for us:</p> <ul> <li>merge constants</li> <li>reassociate expressions: <code>(1 + 2) * (2 + 1) -&gt; (1 + 2) * (1 + 2)</code></li> <li>simplify expressions: <code>(1 + 2) * (1 + 2) -&gt; (1 + 2) ** 2</code></li> <li>simplify branching: control flow and loops</li> <li>remove redundant instructions</li> </ul> <p>You can print the <code>module</code> before and after <code>pm.run(module)</code> and see the difference. Pretty cool, right?</p>"},{"location":"blog/2023/10/13/pascal-llvm-4/#_1","title":"~","text":"<p>If you're reading this, thanks for sticking around! I hope you enjoyed reading this series of posts as much as I enjoyed implementing all this stuff. </p> <p>There are a ton of ways one could improve this implementation, and it's by no means complete, but I feel like it still gives a good perspective of what are the key components.  Let me know in the comments if there are some interesting aspects that I didn't cover!</p>"},{"location":"blog/archive/2023/","title":"2023","text":""},{"location":"blog/category/llvm/","title":"LLVM","text":""}]}